<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ElasticsearchCRUD</name>
    </assembly>
    <members>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchCoreTypes.Similarity">
            <summary>
            "similarity":"BM25"
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBinary.IndexName">
            <summary>
            index_name
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBinary.Compress">
            <summary>
            compress
            Set to true to compress the stored binary value.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBinary.Store">
            <summary>
            store
            Set to true to actually store the field in the index, false to not store it. Defaults to false (note, the JSON document itself is stored, and it can be retrieved from it).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBinary.DocValues">
            <summary>
            doc_values
            Set to true to store field values in a column-stride fashion. Automatically set to true when the fielddata format is doc_values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBinary.CompressThreshold">
            <summary>
            //compress_threshold
            Compression will only be applied to stored binary fields that are greater than this size. Defaults to -1 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBoolean.IndexName">
            <summary>
            index_name
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBoolean.Index">
            <summary>
            index
            Set to no if the value should not be indexed. Setting to no disables include_in_all. If set to no the field should be either stored in _source, have include_in_all enabled, or store be set to true for this to be useful.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBoolean.Store">
            <summary>
            store
            Set to true to actually store the field in the index, false to not store it. Defaults to false (note, the JSON document itself is stored, and it can be retrieved from it).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBoolean.DocValues">
            <summary>
            doc_values
            Set to true to store field values in a column-stride fashion. Automatically set to true when the fielddata format is doc_values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBoolean.Boost">
            <summary>
            boost
            The boost value. Defaults to 1.0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchBoolean.NullValue">
            <summary>
            null_value
            When there is a (JSON) null value for the field, use the null_value as the field value. Defaults to not adding the field at all.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber">
            <summary>
            type The type of the number. Can be float, double, integer, long, short, byte. Required.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.IndexName">
            <summary>
            index_name
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.Store">
            <summary>
            store
            Set to true to actually store the field in the index, false to not store it. Defaults to false (note, the JSON document itself is stored, and it can be retrieved from it).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.Index">
            <summary>
            index
            Set to no if the value should not be indexed. Setting to no disables include_in_all. If set to no the field should be either stored in _source, have include_in_all enabled, or store be set to true for this to be useful.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.DocValues">
            <summary>
            doc_values
            Set to true to store field values in a column-stride fashion. Automatically set to true when the fielddata format is doc_values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.Boost">
            <summary>
            boost
            The boost value. Defaults to 1.0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.NullValue">
            <summary>
            null_value
            When there is a (JSON) null value for the field, use the null_value as the field value. Defaults to not adding the field at all.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.IncludeInAll">
            <summary>
            include_in_all
            Should the field be included in the _all field (if enabled). If index is set to no this defaults to false, otherwise, defaults to true or to the parent object type setting.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.PrecisionStep">
            <summary>
            precision_step
            The precision step (influences the number of terms generated for each number value). Defaults to 16 for long, double, 8 for short, integer, float, and 2147483647 for byte.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.IgnoreMalformed">
            <summary>
            ignore_malformed
            Ignored a malformed number. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNumber.Coerce">
            <summary>
            coerce
            Try convert strings to numbers and truncate fractions for integers. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.Format">
            <summary>
            The date format. Defaults to dateOptionalTime.
            The DateTimeFormats class can be used for this.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.IndexName">
            <summary>
            index_name
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.Store">
            <summary>
            store
            Set to true to actually store the field in the index, false to not store it. Defaults to false (note, the JSON document itself is stored, and it can be retrieved from it).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.DocValues">
            <summary>
            doc_values
            Set to true to store field values in a column-stride fashion. Automatically set to true when the fielddata format is doc_values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.Boost">
            <summary>
            boost
            The boost value. Defaults to 1.0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.NullValue">
            <summary>
            null_value
            When there is a (JSON) null value for the field, use the null_value as the field value. Defaults to not adding the field at all.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.IncludeInAll">
            <summary>
            include_in_all
            Should the field be included in the _all field (if enabled). If index is set to no this defaults to false, otherwise, defaults to true or to the parent object type setting.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.PrecisionStep">
            <summary>
            precision_step
            The precision step (influences the number of terms generated for each number value). Defaults to 16.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchDate.IgnoreMalformed">
            <summary>
            ignore_malformed
            Ignored a malformed number. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.LatLon">
            <summary>
            lat_lon
            Set to true to also index the .lat and .lon as fields. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.Geohash">
            <summary>
            geohash
            Set to true to also index the .geohash as a field. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.GeohashPrecision">
            <summary>
            geohash_precision
            Sets the geohash precision. It can be set to an absolute geohash length or a distance value (eg 1km, 1m, 1ml) 
            defining the size of the smallest cell. Defaults to an absolute length of 12.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.GeohashPrefix">
            <summary>
            geohash_prefix
            If this option is set to true, not only the geohash but also all its parent cells (true prefixes) will be indexed as well. 
            The number of terms that will be indexed depends on the geohash_precision. Defaults to false. Note: This option implicitly enables geohash.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.Validate">
            <summary>
            validate
            Set to true to reject geo points with invalid latitude or longitude (default is false). 
            Note: Validation only works when normalization has been disabled.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.ValidateLat">
            <summary>
            validate_lat
            Set to true to reject geo points with an invalid latitude.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.ValidateLon">
            <summary>
            validate_lon
            Set to true to reject geo points with an invalid longitude.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.Normalize">
            <summary>
            normalize
            Set to true to normalize latitude and longitude (default is true).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.NormalizeLat">
            <summary>
            normalize_lat
            Set to true to normalize latitude.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.NormalizeLon">
            <summary>
            normalize_lon
            Set to true to normalize longitude.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.PrecisionStep">
            <summary>
            precision_step
            The precision step (influences the number of terms generated for each number value) for .lat and .lon fields if lat_lon is set to true. Defaults to 16.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoPoint.FieldDataPrecision">
             <summary>
             "fielddata" : {
                        "format" : "compressed",
                        "precision" : "1cm"
              }
             
             By default, geo points use the array format which loads geo points into two parallel double arrays, making sure there is no precision loss. 
             However, this can require a non-negligible amount of memory (16 bytes per document) which is why Elasticsearch also provides a field data implementation 
             with lossy compression called compressed.
             This field data format comes with a precision option which allows to configure how much precision can be traded for memory. 
             The default value is 1cm. The following table presents values of the memory savings given various precisions:
            
             Precision
             Bytes per point
             Size reduction
            
             1km 4 75%
             3m 6 62.5%
             1cm 8 50%
             1mm 10 37.5%
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoShape.Tree">
            <summary>
            tree
            Name of the PrefixTree implementation to be used: geohash for GeohashPrefixTree and quadtree for QuadPrefixTree. Defaults to geohash.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoShape.Precision">
            <summary>
            precision
            This parameter may be used instead of tree_levels to set an appropriate value for the tree_levels parameter. 
            The value specifies the desired precision and Elasticsearch will calculate the best tree_levels value to honor this precision. 
            The value should be a number followed by an optional distance unit. Valid distance units include: 
            in, inch, yd, yard, mi, miles, km, kilometers, m,meters (default), cm,centimeters, mm, millimeters.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoShape.TreeLevels">
            <summary>
            tree_levels
            Maximum number of layers to be used by the PrefixTree. 
            This can be used to control the precision of shape representations and therefore how many terms are indexed. 
            Defaults to the default value of the chosen PrefixTree implementation. 
            Since this parameter requires a certain level of understanding of the underlying implementation, users may use the precision parameter instead. 
            However, Elasticsearch only uses the tree_levels parameter internally and this is what is returned via the mapping API even if you use the precision parameter.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoShape.DistanceErrorPct">
            <summary>
            distance_error_pct
            Used as a hint to the PrefixTree about how precise it should be. Defaults to 0.025 (2.5%) with 0.5 as the maximum supported value.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchGeoShape.Orientation">
            <summary>
            orientation
            Optionally define how to interpret vertex order for polygons / multipolygons. 
            This parameter defines one of two coordinate system rules (Right-hand or Left-hand) each of which can be specified in three different ways. 
            1. Right-hand rule (default): right, ccw, counterclockwise, 
            2. Left-hand rule: left, cw, clockwise. 
            The default orientation (counterclockwise) complies with the OGC standard which defines outer ring vertices in counterclockwise order with inner ring(s) 
            vertices (holes) in clockwise order. Setting this parameter in the geo_shape mapping explicitly sets vertex order for the coordinate list of a geo_shape field 
            but can be overridden in each individual GeoJSON document.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNestedAttribute">
            <summary>
             This attribute is used if you need to change the structure of the nested objects in Elastissearch to nested nested objects.
            
            Nested fields may contain other nested fields. 
            The include_in_parent object refers to the direct parent of the field, while the include_in_root parameter 
            refers only to the topmost “root” object or document.
            
            Nested docs will automatically use the root doc _all field only.
            
            Internally, nested objects are indexed as additional documents, but, since they can be guaranteed to be indexed within the same "block", 
            it allows for extremely fast joining with parent docs.
            
            Those internal nested documents are automatically masked away when doing operations against the index (like searching with a match_all query), 
            and they bubble out when using the nested query.
            
            Because nested docs are always masked to the parent doc, the nested docs can never be accessed outside the scope of the nested query. 
            For example stored fields can be enabled on fields inside nested objects, but there is no way of retrieving them, 
            since stored fields are fetched outside of the nested query scope.
            
            The _source field is always associated with the parent document and because of that field values via the source can be fetched for nested object.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNestedAttribute.IncludeInParent">
            <summary>
            include_in_parent
            You may want to index inner objects both as nested fields and as flattened object fields, eg for highlighting. This can be achieved by setting include_in_parent to true:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchNestedAttribute.IncludeInRoot">
            <summary>
            include_in_root
            
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.IndexName">
            <summary>
            index_name
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.Store">
            <summary>
            store
            Set to true to actually store the field in the index, false to not store it. Defaults to false (note, the JSON document itself is stored, and it can be retrieved from it).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.Index">
            <summary>
            index
            Set to analyzed for the field to be indexed and searchable after being broken down into token using an analyzer. not_analyzed means that its still searchable, but does not go through any analysis process or broken down into tokens. no means that it won’t be searchable at all (as an individual field; it may still be included in _all). Setting to no disables include_in_all. Defaults to analyzed.	
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.DocValues">
            <summary>
            doc_values
            Set to true to store field values in a column-stride fashion. Automatically set to true when the fielddata format is doc_values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.TermVector">
            <summary>
            term_vector
            Possible values are no, yes, with_offsets, with_positions, with_positions_offsets. Defaults to no.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.Boost">
            <summary>
            boost
            The boost value. Defaults to 1.0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.NullValue">
            <summary>
            null_value
            When there is a (JSON) null value for the field, use the null_value as the field value. Defaults to not adding the field at all.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.NormsEnabled">
            <summary>
            norms: {enabled: value}
            Boolean value if norms should be enabled or not. Defaults to true for analyzed fields, and to false for not_analyzed fields. See the section about norms.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.NormsLoading">
            <summary>
            norms: {loading: value}
            Describes how norms should be loaded, possible values are eager and lazy (default). It is possible to change the default value to eager for all fields by configuring the index setting index.norms.loading to eager.		
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.IndexOptions">
            <summary>
            index_options
            Allows to set the indexing options, possible values are docs (only doc numbers are indexed), freqs (doc numbers and term frequencies), and positions (doc numbers, term frequencies and positions). Defaults to positions for analyzed fields, and to docs for not_analyzed fields. It is also possible to set it to offsets (doc numbers, term frequencies, positions and offsets).	
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.Analyzer">
            <summary>
            analyzer
            The analyzer used to analyze the text contents when analyzed during indexing and when searching using a query string. Defaults to the globally configured analyzer.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.IndexAnalyzer">
            <summary>
            index_analyzer
            The analyzer used to analyze the text contents when analyzed during indexing.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.SearchAnalyzer">
            <summary>
            search_analyzer
            The analyzer used to analyze the field when part of a query string. Can be updated on an existing field.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.IncludeInAll">
            <summary>
            include_in_all
            Should the field be included in the _all field (if enabled). If index is set to no this defaults to false, otherwise, defaults to true or to the parent object type setting.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.IgnoreAbove">
            <summary>
            ignore_above
            The analyzer will ignore strings larger than this size. Useful for generic not_analyzed fields that should ignore long text.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.ElasticsearchString.PositionOffsetGap">
            <summary>
            position_offset_gap
            Position increment gap between field instances with the same field name. Defaults to 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.CoreTypeAttributes.Fields.FieldClass">
            <summary>
            You can define all the Elasticsearch properties here
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexMappings.CreatePropertyMappingForEntityForParentDocument(ElasticsearchCRUD.Model.EntityContextInfo,ElasticsearchCRUD.ElasticsearchMapping,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingDefinition)">
            <summary>
            Create a new index for the parent document
            </summary>
            <param name="entityInfo"></param>
            <param name="elasticsearchMapping"></param>
            <param name="mappingDefinition">mapping definitions for the index type</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexMappings.CreatePropertyMappingForChildDocument(ElasticsearchCRUD.Model.EntityContextInfo,ElasticsearchCRUD.ElasticsearchMapping,ElasticsearchCRUD.Model.EntityContextInfo,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingDefinition)">
            <summary>
            Create a new mapping for the child type in the parent document index
            </summary>
            <param name="entityInfo"></param>
            <param name="elasticsearchMapping"></param>
            <param name="item"></param>
            <param name="mappingDefinition">definition for the type mappings</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexMappings.CreateForceRoutingMappingForDocument(ElasticsearchCRUD.ElasticsearchCrudJsonWriter)">
            <summary>
            "_routing": {
            "required": true
            },
            </summary>
            <param name="elasticsearchCrudJsonWriter"></param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexMappings.CreateIndexSettings(ElasticsearchCRUD.ElasticsearchCrudJsonWriter,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexSettings)">
            "settings" : {
            "number_of_shards" : 1
            },
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.BaseStopAnalyzer.Stopwords">
            <summary>
            A list of stopwords to initialize the stop filter with. Defaults to the english stop words.
            Use stopwords: _none_ to explicitly specify an empty stopword list.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.CustomAnalyzer">
             <summary>
             The standard analyzer, which is the default analyzer used for full-text fields, is a good choice for most Western languages. It consists of the following:
            
            	The standard tokenizer, which splits the input text on word boundaries
            	The standard token filter, which is intended to tidy up the tokens emitted by the tokenizer (but currently does nothing)
            	The lowercase token filter, which converts all tokens into lowercase
            	The stop token filter, which removes stopwords—common words that have little impact on search relevance, such as a, the, and, is. 
            
             By default, the stopwords filter is disabled. You can enable it by creating a custom analyzer based on the standard analyzer and setting the stopwords parameter. 
             Either provide a list of stopwords or tell it to use a predefined stopwords list from a particular language.
            
             "analyzer" : {
            		"blocks_analyzer" : {
            			"type" : "custom",
            			"tokenizer" : "whitespace",
            			"filter" : ["lowercase", "blocks_filter", "shingle"]
            		}
            	}
             </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.LanguageAnalyzer.#ctor(System.String,System.String)">
             <summary>
             A set of analyzers aimed at analyzing specific language text. The following types are supported: 
             arabic, armenian, basque, brazilian, bulgarian, catalan, chinese, cjk, czech, danish, dutch, english, finnish, french, galician, 
             german, greek, hindi, hungarian, indonesian, irish, italian, latvian, norwegian, persian, portuguese, romanian, 
             russian, sorani, spanish, swedish, turkish, thai.
             
             Configuring language analyzersedit
             Stopwordsedit
             All analyzers support setting custom stopwords either internally in the config, or by using an external stopwords file by setting stopwords_path. 
            
             The following analyzers support setting custom stem_exclusion list: 
             arabic, armenian, basque, catalan, bulgarian, catalan, czech, finnish, dutch, english, finnish, french, galician, 
             german, irish, hindi, hungarian, indonesian, italian, latvian, norwegian, portuguese, romanian, russian, sorani, spanish, swedish, turkish.
             </summary>
             <param name="name">name of the analyzer</param>
             <param name="analyzer">required for language analyzers</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.LanguageAnalyzer.StopwordsPath">
            <summary>
            stopwords_path
            A path (either relative to config location, or absolute) to a stopwords file configuration.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.LanguageAnalyzer.StemExclusion">
            <summary>
            Excluding words from stemmingedit
            The stem_exclusion parameter allows you to specify an array of lowercase words that should not be stemmed. Internally, 
            this functionality is implemented by adding the keyword_marker token filter with the keywords set to the value of the stem_exclusion parameter.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.PatternAnalyzer.Lowercase">
            <summary>
            lowercase  Should terms be lowercased or not. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.PatternAnalyzer.Pattern">
            <summary>
            pattern The regular expression pattern, defaults to \W+.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.PatternAnalyzer.Flags">
             <summary>
             flags The regular expression flags.
             IMPORTANT: The regular expression should match the token separators, not the tokens themselves.
            
             Flags should be pipe-separated, eg "CASE_INSENSITIVE|COMMENTS". Check Java Pattern API for more details about flags options.
             </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.SnowballAnalyzer.#ctor(System.String)">
            <summary>
            An analyzer of type snowball that uses the standard tokenizer, with standard filter, lowercase filter, stop filter, and snowball filter.
            The Snowball Analyzer is a stemming analyzer from Lucene that is originally based on the snowball project from snowball.tartarus.org.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.StandardAnaylzer.MaxTokenLength">
            <summary>
            max_token_length
            The maximum token length. If a token is seen that exceeds this length then it is discarded. Defaults to 255.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.StopAnalyzer.#ctor(System.String)">
            <summary>
            An analyzer of type stop that is built using a Lower Case Tokenizer, with Stop Token Filter.
            </summary>
            <param name="name">name of the analyzer</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Analyzers.StopAnalyzer.StopwordsPath">
            <summary>
            stopwords_path
            A path (either relative to config location, or absolute) to a stopwords file configuration.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.CharFilters.MappingCharFilter.#ctor(System.String)">
            <summary>
            A char filter of type mapping replacing characters of an analyzed text with given mapping.
            "char_filter" : {
              "my_mapping" : {
            	"type" : "mapping",
            	"mappings" : ["ph=>f", "qu=>k"]
              }
            },
            </summary>
            <param name="name">name for the custom mapping char filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.CharFilters.MappingCharFilter.Mappings">
            <summary>
            mappings
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.CharFilters.MappingCharFilter.MappingsPath">
            <summary>
            mappings_path
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.CharFilters.PatternReplaceCharFilter.#ctor(System.String)">
            <summary>
            The pattern_replace char filter allows the use of a regex to manipulate the characters in a string before analysis. 
            The regular expression is defined using the pattern parameter, and the replacement string can be provided using the replacement parameter 
            (supporting referencing the original text, as explained here).
            "char_filter" : {
              "my_pattern":{
                "type":"pattern_replace",
                "pattern":"sample(.*)",
             	"replacement":"replacedSample $1"
              }
            },
            </summary>
            <param name="name">name for the custom pattern replace char filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.CharFilters.PatternReplaceCharFilter.Pattern">
            <summary>
            pattern
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.CharFilters.PatternReplaceCharFilter.Replacement">
            <summary>
            replacement
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.AsciifoldingTokenFilter.#ctor(System.String)">
            <summary>
            A token filter of type asciifolding that converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters 
            (the "Basic Latin" Unicode block) into their ASCII equivalents, if one exists.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.AsciifoldingTokenFilter.PreserveOriginal">
            <summary>
            Accepts preserve_original setting which defaults to false but if true will keep the original token as well as emit the folded token.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CjkBigramTokenFilter.#ctor(System.String)">
            <summary>
            The cjk_bigram token filter forms bigrams out of the CJK terms that are generated by the standard tokenizer or the icu_tokenizer (see ICU Analysis Plugin).
            By default, when a CJK character has no adjacent characters to form a bigram, it is output in unigram form. If you always want to output both unigrams and bigrams, 
            set the output_unigrams flag to true. This can be used for a combined unigram+bigram approach
            Bigrams are generated for characters in han, hiragana, katakana and hangul, but bigrams can be disabled for particular scripts with the ignore_scripts parameter. 
            All non-CJK input is passed through unmodified.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CjkBigramTokenFilter.IgnoreScripts">
            <summary>
            ignore_scripts
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CjkBigramTokenFilter.OutputUnigrams">
            <summary>
            output_unigrams
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CommonGramsFilter.#ctor(System.String)">
            <summary>
            Token filter that generates bigrams for frequently occuring terms. Single terms are still indexed. It can be used as an alternative to the
            Stop Token Filter when we don’t want to completely ignore common terms.
            For example, the text "the quick brown is a fox" will be tokenized as "the", "the_quick", "quick", "brown", "brown_is", "is_a", "a_fox", "fox". 
            Assuming "the", "is" and "a" are common words.
            
            When query_mode is enabled, the token filter removes common words and single terms followed by a common word. 
            This parameter should be enabled in the search analyzer.
            For example, the query "the quick brown is a fox" will be tokenized as "the_quick", "quick", "brown_is", "is_a", "a_fox", "fox".
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CommonGramsFilter.CommonWords">
            <summary>
            common_words
            A list of common words to use.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CommonGramsFilter.CommonWordsPath">
            <summary>
            common_words_path
            A path (either relative to config location, or absolute) to a list of common words. Each word should be in its own "line" (separated by a line break). The file must be UTF-8 encoded.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CommonGramsFilter.IgnoreCase">
            <summary>
            ignore_case
            If true, common words matching will be case insensitive (defaults to false).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CommonGramsFilter.QueryMode">
            <summary>
            query_mode
            Generates bigrams then removes common words and single terms followed by a common word (defaults to false).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.WordList">
            <summary>
            word_list
            A list of words to use.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.WordListPath">
            <summary>
            word_list_path
            A path (either relative to config location, or absolute) to a list of words.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.HyphenationPatternsPath">
            <summary>
            hyphenation_patterns_path
            A path (either relative to config location, or absolute) to a FOP XML hyphenation pattern file. 
            (See http://offo.sourceforge.net/hyphenation/) Required for hyphenation_decompounder.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.MinWordSize">
            <summary>
            min_word_size
            Minimum word size(Integer). Defaults to 5.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.MinSubwordSize">
            <summary>
            min_subword_size
            Minimum subword size(Integer). Defaults to 2.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.MaxSubwordSize">
            <summary>
            max_subword_size
            Maximum subword size(Integer). Defaults to 15.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.CompoundWordTokenFilter.OnlyLongestMatch">
            <summary>
            only_longest_match
            Only matching the longest(Boolean). Defaults to false
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.DelimitedPayloadFilterTokenFilter.#ctor(System.String)">
            <summary>
            Named delimited_payload_filter. Splits tokens into tokens and payload whenever a delimiter character is found.
            Example: "the|1 quick|2 fox|3" is split per default int to tokens fox, quick and the with payloads 1, 2 and 3 respectively.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.DelimitedPayloadFilterTokenFilter.Delimiter">
            <summary>
            delimiter
            Character used for splitting the tokens. Default is |. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.DelimitedPayloadFilterTokenFilter.Encoding">
            <summary>
            encoding
            The type of the payload. int for integer, float for float and identity for characters. Default is float. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.EdgeNGramTokenFilter.MinGram">
            <summary>
            min_gram Minimum size in codepoints of a single n-gram
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.EdgeNGramTokenFilter.MaxGram">
            <summary>
             max_gram Maximum size in codepoints of a single n-gram
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.EdgeNGramTokenFilter.Side">
            <summary>
            Either front or back. Defaults to front.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ElisionTokenFilter.#ctor(System.String)">
            <summary>
            A token filter which removes elisions. For example, "l’avion" (the plane) will tokenized as "avion" (plane). 
            Accepts articles setting which is a set of stop words articles. 
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ElisionTokenFilter.Articles">
            <summary>
            articles
            Accepts articles setting which is a set of stop words articles. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.HunspellTokenFilter.#ctor(System.String)">
            <summary>
            Basic support for hunspell stemming. Hunspell dictionaries will be picked up from a dedicated hunspell directory on the filesystem 
            (defaults to path.conf/hunspell). Each dictionary is expected to have its own directory named after its associated locale (language).
            This dictionary directory is expected to hold a single *.aff and one or more *.dic files (all of which will automatically be picked up). 
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.HunspellTokenFilter.Locale">
            <summary>
            locale
            A locale for this filter. If this is unset, the lang or language are used instead - so one of these has to be set. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.HunspellTokenFilter.Dictionary">
            <summary>
            dictionary
            The name of a dictionary. The path to your hunspell dictionaries should be configured via indices.analysis.hunspell.dictionary.location before.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.HunspellTokenFilter.Dedup">
            <summary>
            dedup
            If only unique terms should be returned, this needs to be set to true. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.HunspellTokenFilter.LongestOnly">
            <summary>
            longest_only
            If only the longest term should be returned, set this to true. Defaults to false: all possible stems are returned. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.Language">
            <summary>
            language
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.Strength">
            <summary>
            strength
            The strength property determines the minimum level of difference considered significant during comparison. 
            The default strength for the Collator is tertiary, unless specified otherwise by the locale used to create the Collator. 
            Possible values: primary, secondary, tertiary, quaternary or identical. See ICU Collation documentation for a more detailed explanation for the specific values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.Decomposition">
            <summary>
            decomposition
            Possible values: no or canonical. Defaults to no. Setting this decomposition property with canonical allows the Collator to handle un-normalized text properly, 
            producing the same results as if the text were normalized. If no is set, it is the user’s responsibility to insure that all text is already in the appropriate form 
            before a comparison or before getting a CollationKey. Adjusting decomposition mode allows the user to select between faster and more complete collation behavior. 
            Since a great many of the world’s languages do not require text normalization, most locales set no as the default decomposition mode.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.Alternate">
            <summary>
            alternate
            Possible values: shifted or non-ignorable. Sets the alternate handling for strength quaternary to be either shifted or non-ignorable. 
            What boils down to ignoring punctuation and whitespace.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.CaseLevel">
            <summary>
            caseLevel
            Possible values: true or false. Default is false. Whether case level sorting is required. When strength is set to primary this will ignore accent differences.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.CaseFirst">
            <summary>
            caseFirst
            Possible values: lower or upper. Useful to control which case is sorted first when case is not ignored for strength tertiary.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.Numeric">
            <summary>
            numeric
            Possible values: true or false. Whether digits are sorted according to numeric representation. 
            For example the value egg-9 is sorted before the value egg-21. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.VariableTop">
            <summary>
            variableTop
            Single character or contraction. Controls what is variable for alternate.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuCollationTokenFilter.HiraganaQuaternaryMode">
            <summary>
            hiraganaQuaternaryMode
            Possible values: true or false. Defaults to false. Distinguishing between Katakana and Hiragana characters in quaternary strength .
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.IcuFoldingTokenFilter.UnicodeSetFilter">
            <summary>
            unicodeSetFilter
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeepTokenFilter.#ctor(System.String)">
            <summary>
            A token filter of type keep that only keeps tokens with text contained in a predefined set of words. 
            The set of words can be defined in the settings or loaded from a text file containing one word per line.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeepTokenFilter.KeepWords">
            <summary>
            keep_words
            a list of words to keep
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeepTokenFilter.KeepWordsPath">
            <summary>
            keep_words_path
            a path to a words file
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeepTokenFilter.KeepWordsCase">
            <summary>
            keep_words_case
            a boolean indicating whether to lower case the words (defaults to false) 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeepTypesTokenFilter.#ctor(System.String)">
            <summary>
            A token filter of type keep_types that only keeps tokens with a token type contained in a predefined set.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeepTypesTokenFilter.Types">
            <summary>
            A list of types to keep 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeywordMarkerTokenFilter.#ctor(System.String)">
            <summary>
            Protects words from being modified by stemmers. Must be placed before any stemming filters.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeywordMarkerTokenFilter.Keywords">
            <summary>
            keywords
            A list of mapping rules to use.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeywordMarkerTokenFilter.KeywordsPath">
            <summary>
            rules_path
            A path (either relative to config location, or absolute) to a list of words.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.KeywordMarkerTokenFilter.IgnoreCase">
            <summary>
            ignore_case
            Set to true to lower case all words first. Defaults to false.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.LengthTokenFilter.#ctor(System.String)">
            <summary>
            A token filter of type length that removes words that are too long or too short for the stream.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.LimitTokenFilter.#ctor(System.String)">
            <summary>
            Limits the number of tokens that are indexed per document and field.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.LimitTokenFilter.MaxTokenCount">
            <summary>
            max_token_count
            The maximum number of tokens that should be indexed per document and field. The default is 1
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.LimitTokenFilter.ConsumeAllTokens">
            <summary>
            consume_all_tokens
            If set to true the filter exhaust the stream even if max_token_count tokens have been consumed already. The default is false.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.LowercaseTokenFilter.#ctor(System.String)">
            <summary>
            A token filter of type lowercase that normalizes token text to lower case. 
            Lowercase token filter supports Greek, Irish, and Turkish lowercase token filters through the language parameter.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.NGramTokenFilter.MinGram">
            <summary>
            min_gram Minimum size in codepoints of a single n-gram
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.NGramTokenFilter.MaxGram">
            <summary>
             max_gram Maximum size in codepoints of a single n-gram
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.PatternCaptureTokenFilter.#ctor(System.String)">
            <summary>
            The pattern_capture token filter, unlike the pattern tokenizer, emits a token for every capture group in the regular expression. 
            Patterns are not anchored to the beginning and end of the string, so each pattern can match multiple times, and matches are allowed to overlap.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.PatternCaptureTokenFilter.PreserveOriginal">
            <summary>
            preserve_original
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.PatternReplaceTokenFilter.#ctor(System.String)">
            <summary>
            The pattern_replace token filter allows to easily handle string replacements based on a regular expression. 
            The regular expression is defined using the pattern parameter, and the replacement string can be provided using the replacement parameter
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.PhoneticTokenFilter.#ctor(System.String)">
             <summary>
             https://github.com/elasticsearch/elasticsearch-analysis-phonetic
             A phonetic token filter that can be configured with different encoder types: 
             metaphone, doublemetaphone, soundex, refinedsoundex, caverphone1, caverphone2, cologne, nysiis, koelnerphonetik, haasephonetik, beidermorse
            
             The replace parameter (defaults to true) controls if the token processed should be replaced with the encoded one (set it to true), or added (set it to false).
             </summary>
             <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.PhoneticTokenFilter.Encoder">
            <summary>
            A phonetic token filter that can be configured with different encoder types: 
            metaphone, doublemetaphone, soundex, refinedsoundex, caverphone1, caverphone2, cologne, nysiis, koelnerphonetik, haasephonetik, beidermorse
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.PhoneticTokenFilter.Replace">
            <summary>
            The replace parameter (defaults to true) controls if the token processed should be replaced with the encoded one (set it to true), or added (set it to false).
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ShingleTokenFilter.#ctor(System.String)">
            <summary>
            A token filter of type shingle that constructs shingles (token n-grams) from a token stream. 
            In other words, it creates combinations of tokens as a single token. For example, the sentence "please divide this sentence 
            into shingles" might be tokenized into shingles "please divide", "divide this", "this sentence", "sentence into", and "into shingles".
            This filter handles position increments > 1 by inserting filler tokens (tokens with termtext "_"). 
            It does not handle a position increment of 0.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ShingleTokenFilter.OutputUnigrams">
            <summary>
            If true the output will contain the input tokens (unigrams) as well as the shingles. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ShingleTokenFilter.OutputUnigramsIfNoShingles">
            <summary>
            If output_unigrams is false the output will contain the input tokens (unigrams) if no shingles are available. 
            Note if output_unigrams is set to true this setting has no effect. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ShingleTokenFilter.TokenSeparator">
            <summary>
            The string to use when joining adjacent tokens to form a shingle. Defaults to " ".
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.ShingleTokenFilter.FillerToken">
            <summary>
            The string to use as a replacement for each position at which there is no actual token in the stream. 
            For instance this string is used if the position increment is greater than one 
            when a stop filter is used together with the shingle filter. Defaults to "_"
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.SnowballTokenFilter">
            <summary>
            A filter that stems words using a Snowball-generated stemmer. 
            The language parameter controls the stemmer with the following available values: 
            Armenian, Basque, Catalan, Danish, Dutch, English, Finnish, French, German, German2, Hungarian, 
            Italian, Kp, Lovins, Norwegian, Porter, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.SnowballTokenFilter.#ctor(System.String)">
            <summary>
            A filter that stems words using a Snowball-generated stemmer. 
            The language parameter controls the stemmer with the following available values: 
            Armenian, Basque, Catalan, Danish, Dutch, English, Finnish, French, German, German2, Hungarian, 
            Italian, Kp, Lovins, Norwegian, Porter, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StemmerOverrideTokenFilter.#ctor(System.String)">
             <summary>
             Overrides stemming algorithms, by applying a custom mapping, then protecting these terms from being modified by stemmers. Must be placed before any stemming filters.
            
             Rules are separated by =>
             </summary>
             <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StemmerOverrideTokenFilter.Rules">
            <summary>
            rules
            A list of mapping rules to use.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StemmerOverrideTokenFilter.RulesPath">
            <summary>
            rules_path
            A path (either relative to config location, or absolute) to a list of mappings.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StemmerTokenFilter.#ctor(System.String)">
            <summary>
            A filter that provides access to (almost) all of the available stemming token filters through a single unified interface
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StemmerTokenFilter.StemmerName">
            <summary>
            Either front or back. Defaults to front.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StopTokenFilter.Stopwords">
            <summary>
            A list of stopwords to initialize the stop filter with. Defaults to the english stop words.
            Use stopwords: _none_ to explicitly specify an empty stopword list.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StopTokenFilter.StopwordsPath">
            <summary>
            stopwords_path
            A path (either relative to config location, or absolute) to a stopwords file configuration.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StopTokenFilter.IgnoreCase">
            <summary>
            ignore_case
            Set to true to lower case all words first. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.StopTokenFilter.RemoveTrailing">
            <summary>
            remove_trailing
            Set to false in order to not ignore the last term of a search if it is a stop word. 
            This is very useful for the completion suggester as a query like green a can be 
            extended to green apple even though you remove stop words in general. Defaults to true. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.SynonymTokenFilter.#ctor(System.String)">
             <summary>
             The synonym token filter allows to easily handle synonyms during the analysis process. Synonyms are configured using a configuration file. 
             Additional settings are: ignore_case (defaults to false), and expand (defaults to true).
            
             The tokenizer parameter controls the tokenizers that will be used to tokenize the synonym, and defaults to the whitespace tokenizer.
             </summary>
             <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.SynonymTokenFilter.SynonymsPath">
            <summary>
            synonyms_path
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.SynonymTokenFilter.Synonyms">
            <summary>
            Two synonym formats are supported: Solr, WordNet.
            These can be defined directly with this parameter.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.TruncateTokenFilter.#ctor(System.String)">
            <summary>
            The truncate token filter can be used to truncate tokens into a specific length. This can come in handy with keyword (single token) based mapped fields that are used for sorting in order to reduce memory usage.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.TruncateTokenFilter.Length">
            <summary>
            length
            It accepts a length parameter which control the number of characters to truncate to, defaults to 10.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.UniqueTokenFilter.#ctor(System.String)">
            <summary>
            The unique token filter can be used to only index unique tokens during analysis. 
            By default it is applied on all the token stream. If only_on_same_position is set to true, it will only remove duplicate tokens on the same position.
            </summary>
            <param name="name">name for the custom filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.UniqueTokenFilter.OnlyOnSamePosition">
            <summary>
            only_on_same_position
            Accepts articles setting which is a set of stop words articles. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.#ctor(System.String)">
             <summary>
             Named word_delimiter, it Splits words into subwords and performs optional transformations on subword groups. Words are split into subwords with the following rules:
            
             split on intra-word delimiters (by default, all non alpha-numeric characters).
               "Wi-Fi" → "Wi", "Fi"
               split on case transitions: "PowerShot" → "Power", "Shot"
               split on letter-number transitions: "SD500" → "SD", "500"
               leading and trailing intra-word delimiters on each subword are ignored: "//hello---there, dude" → "hello", "there", "dude"
               trailing "'s" are removed for each subword: "O’Neil’s" → "O", "Neil" 
             </summary>
             <param name="name">name for the filter</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.GenerateWordParts">
            <summary>
            generate_word_parts
            If true causes parts of words to be generated: "PowerShot" ⇒ "Power" "Shot". Defaults to true. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.GenerateNumberParts">
            <summary> 
            generate_number_parts
            If true causes number subwords to be generated: "500-42" ⇒ "500" "42". Defaults to true. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.CatenateWords">
            <summary>
            catenate_words
            If true causes maximum runs of word parts to be catenated: "wi-fi" ⇒ "wifi". Defaults to false. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.CatenateNumbers">
            <summary>
            catenate_numbers
            If true causes maximum runs of number parts to be catenated: "500-42" ⇒ "50042". Defaults to false. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.CatenateAll">
            <summary>
            catenate_all
            If true causes all subword parts to be catenated: "wi-fi-4000" ⇒ "wifi4000". Defaults to false. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.SplitOnCaseChange">
            <summary>
            split_on_case_change
            If true causes "PowerShot" to be two tokens; ("Power-Shot" remains two parts regards). Defaults to true. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.PreserveOriginal">
            <summary>
            preserve_original
            If true includes original words in subwords: "500-42" ⇒ "500-42" "500" "42". Defaults to false. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.SplitOnNumerics">
            <summary>
            split_on_numerics
            If true causes "j2se" to be three tokens; "j" "2" "se". Defaults to true. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.StemEnglishPossessive">
            <summary>
            stem_english_possessive
            If true causes trailing "'s" to be removed for each subword: "O’Neil’s" ⇒ "O", "Neil". Defaults to true. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.ProtectedWords">
            <summary>
            protected_words
            A list of protected words from being delimiter. Either an array, or also can set protected_words_path which resolved to a file configured 
            with protected words (one on each line). Automatically resolves to config/ based location if exists. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.ProtectedWordsPath">
            <summary>
            protected_words_path see protected_words
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Filters.WordDelimiterTokenFilter.TypeTable">
            <summary>
            type_table
            A custom type mapping table, for example (when configured using type_table_path):
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexAlias">
            <summary>
            This model is only used when creating an index. If it is required that an index is added later, use the alias api.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexAlias.Routing">
            <summary>
            It is possible to associate routing values with aliases. This feature can be used together with filtering aliases in order to avoid unnecessary shard operations.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexAlias.Filter">
            <summary>
            An optional filter that can be associated with an alias.
            TODO replace this raw json string with a filter object once the filter class has been created.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexDefinition.Mapping">
            <summary>
            TODO change this to a list so n mappings can be defined
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.NumberOfReplicas">
            <summary>
            index.number_of_replicas
            The number of replicas each shard has. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RefreshInterval">
            <summary>
            index.refresh_interval
            The async refresh interval of a shard. 
            -----
            bulk Indexing Usage 
            For example, the update settings API can be used to dynamically change the index from being more performant for bulk indexing, 
            and then move it to more real time indexing state. Before the bulk indexing is started, use:
             "refresh_interval" : "-1"
            (Another optimization option is to start the index without any replicas, and only later adding them, but that really depends on the use case).
            Then, once bulk indexing is done, the settings can be updated (back to the defaults for example):
            "refresh_interval" : "1s"
            And, an optimize should be called:
            curl -XPOST 'http://localhost:9200/test/_optimize?max_num_segments=5'
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.AutoExpandReplicas">
            <summary>
            index.auto_expand_replicas (string)
            Set to a dash delimited lower and upper bound (e.g. 0-5) or one may use all as the upper bound (e.g. 0-all), or false to disable it. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.BlocksReadOnly">
            <summary>
            index.blocks.read_only
            Set to true to have the index read only, false to allow writes and metadata changes. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.BlocksRead">
            <summary>
            index.blocks.read
            Set to true to disable read operations against the index. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.BlocksWrite">
            <summary>
            index.blocks.write
            Set to true to disable write operations against the index. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.BlocksMetadata">
            <summary>
            index.blocks.metadata
            Set to true to disable metadata operations against the index.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.IndexConcurrency">
            <summary>
            index.index_concurrency
            Defaults to 8. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.CodecBloomLoad">
            <summary>
            index.codec.bloom.load
            Whether to load the bloom filter. Defaults to false. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.FailOnMergeFailure">
            <summary>
            index.fail_on_merge_failure
            Default to true. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.TranslogFlushThresholdOps">
            <summary>
            index.translog.flush_threshold_ops
            When to flush based on operations. 
            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/index-modules-translog.html
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.TranslogFlushThresholdSize">
            <summary>
            index.translog.flush_threshold_size
            When to flush based on translog (bytes) size. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.TranslogflushThresholdPeriod">
            <summary>
            index.translog.flush_threshold_period
            When to flush based on a period of not flushing. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.TranslogDisableFlush">
            <summary>
            index.translog.disable_flush
            Disables flushing. Note, should be set for a short interval and then enabled.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.CacheFilterMaxSize">
            <summary>
            index.cache.filter.max_size
            The maximum size of filter cache (per segment in shard). Set to -1 to disable. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.CacheFilterExpire">
            <summary>
            index.cache.filter.expire
            The expire after access time for filter cache. Set to -1 to disable. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.GatewaySnapshotInterval">
            <summary>
            index.gateway.snapshot_interval
            The gateway snapshot interval (only applies to shared gateways). Defaults to 10s. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RoutingAllocationInclude">
            <summary>
            index.routing.allocation.include.*
            A node matching any rule will be allowed to host shards from the index. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RoutingAllocationExclude">
            <summary>
            index.routing.allocation.exclude.*
            A node matching any rule will NOT be allowed to host shards from the index. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RoutingAllocationRequire">
            <summary>
            index.routing.allocation.require.*
            Only nodes matching all rules will be allowed to host shards from the index. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RoutingAllocationEnable">
            <summary>
            index.routing.allocation.enable
            Enables shard allocation for a specific index. It can be set to:
            all (default) - Allows shard allocation for all shards.
            primaries - Allows shard allocation only for primary shards.
            new_primaries - Allows shard allocation only for primary shards for new indices.
            none - No shard allocation is allowed. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RoutingAllocationTotalShardsPerNode">
            <summary>
            index.routing.allocation.total_shards_per_node
            Controls the total number of shards (replicas and primaries) allowed to be allocated on a single node. Defaults to unbounded (-1). 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.RecoveryInitialShards">
             <summary>
             index.recovery.initial_shards
            	When using local gateway a particular shard is recovered only if there can be allocated quorum shards in the cluster. It can be set to:
            
            		quorum (default)
            		quorum-1 (or half)
            		full
            		full-1.
            		Number values are also supported, e.g. 1. 
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.TtlDisablePurge">
            <summary>
            index.ttl.disable_purge
            Disables temporarily the purge of expired docs. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.GcDeletes">
            <summary>
            index.gc_deletes
            Disables temporarily the purge of expired docs. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.TranslogFsType">
            <summary>
            index.translog.fs.type
            Either simple or buffered (default). 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.CompoundFormat">
            <summary>
            index.compound_format
            See index.compound_format in the section called “Index Settingsedit”. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.CompoundOnFlush">
            <summary>
            index.compound_on_flush
            See `index.compound_on_flush in the section called “Index Settingsedit”. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings.WarmerEnabled">
            <summary>
            index.warmer.enabled
            See Warmers. Defaults to true. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingAll">
            <summary>
            The idea of the _all field is that it includes the text of one or more other fields within the document indexed. 
            It can come very handy especially for search requests, where we want to execute a search query against the content of a document, 
            without knowing which fields to search on. This comes at the expense of CPU cycles and index size.
            The _all fields can be completely disabled. Explicit field mappings and object mappings can be excluded / included in the _all field. 
            By default, it is enabled and all fields are included in it for ease of use.
            When disabling the _all field, it is a good practice to set index.query.default_field to a different value 
            (for example, if you have a main "message" field in your data, set it to message).
            One of the nice features of the _all field is that it takes into account specific fields boost levels. 
            Meaning that if a title field is boosted more than content, the title (part) in the _all field will mean more than the content (part) in the _all field.
            "_all" : {"enabled" : true}
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingAnalyzer">
            <summary>
            The _analyzer mapping allows to use a document field property as the name of the analyzer that will be used to index the document. 
            The analyzer will be used for any field that does not explicitly defines an analyzer or index_analyzer when indexing.
            {
             "type1" : {
            	"_analyzer" : {
            		"path" : "my_field"
            	}
              }
            }
            
            The above will use the value of the my_field to lookup an analyzer registered under it. For example, indexing the following doc:
            {
             	"my_field" : "whitespace"
             }
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingSource.Enabled">
            <summary>
            The _source field is an automatically generated field that stores the actual JSON that was used as the indexed document. 
            It is not indexed (searchable), just stored. When executing "fetch" requests, like get or search, the _source field is returned by default.
            Though very handy to have around, the source field does incur storage overhead within the index. For this reason, it can be disabled.
            {
              "tweet" : {
            	"_source" : {"enabled" : false}
              }
            }
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingSource.Includes">
            <summary>
            {
               "my_type" : {
                  "_source" : {
            		"includes" : ["path1.*", "path2.*"],
            		"excludes" : ["path3.*"]
            	}
             }
            }
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters.GetOptimizeParameters">
            <summary>
            Returns the set parameters for the optimize Request
            </summary>
            <returns></returns>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters.NumberOfShards">
            <summary>
            max_num_segments
            The number of segments to optimize to. To fully optimize the index, set it to 1. Defaults to simply checking if a merge needs to execute, and if so, executes it.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters.OnlyExpungeDeletesSet">
            <summary>
            only_expunge_deletes
            Should the optimize process only expunge segments with deletes in it. In Lucene, a document is not deleted from a segment, just marked as deleted. 
            During a merge process of segments, a new segment is created that does not have those deletes. 
            This flag allows to only merge segments that have deletes. Defaults to false. 
            Note that this won’t override the index.merge.policy.expunge_deletes_allowed threshold.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters.Flush">
            <summary>
            flush
            Should a flush be performed after the optimize. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters.WaitForMerge">
            <summary>
            wait_for_merge
            Should the request wait for the merge to end. Defaults to true. Note, a merge can potentially be a very heavy operation, so it might make sense to run it set to false. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.Bm25Similarity.#ctor(System.String)">
            <summary>
            Another TF/IDF based similarity that has built-in tf normalization and is supposed to work better for short fields (like names). 
            See Okapi_BM25 for more details. 
            http://en.wikipedia.org/wiki/Okapi_BM25
            
            The most interesting competitor to TF/IDF and the vector space model is called Okapi BM25, which is considered to be a state-of-the-art ranking function. 
            BM25 originates from the probabilistic relevance model, rather than the vector space model, yet the algorithm has a lot in common with Lucene’s practical scoring function.
            Both use of term frequency, inverse document frequency, and field-length normalization, but the definition of each of these factors is a little different. 
            Rather than explaining the BM25 formula in detail, we will focus on the practical advantages that BM25 offers.
            
            http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/pluggable-similarites.html
            https://www.found.no/foundation/similarity/
            </summary>
            <param name="name">name for the custom similarity</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.Bm25Similarity.K1">
            <summary>
            k1
            Controls non-linear term frequency normalization (saturation).
            This parameter controls how quickly an increase in term frequency results in term-frequency saturation.
            The default value is 1.2. Lower values result in quicker saturation, and higher values in slower saturation. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.Bm25Similarity.B">
            <summary>
            b
            Controls to what degree document length normalizes tf values.
            This parameter controls how much effect field-length normalization should have. 
            A value of 0.0 disables normalization completely, and a value of 1.0 normalizes fully. The default is 0.75. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.Bm25Similarity.DiscountOverlaps">
            <summary>
            Determines whether overlap tokens (Tokens with 0 position increment) are ignored when computing norm. By default this is true, 
            meaning overlap tokens do not count when computing norms. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.DefaultSimilarity.#ctor(System.String)">
            <summary>
            The default similarity that is based on the TF/IDF model. 
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.DefaultSimilarity.DiscountOverlaps">
            <summary>
            discount_overlaps
            Determines whether overlap tokens (Tokens with 0 position increment) are ignored when computing norm. By default this is true, 
            meaning overlap tokens do not count when computing norms. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.DfrSimilarity.#ctor(System.String)">
            <summary>
            Similarity that implements the divergence from randomness framework.
            http://lucene.apache.org/core/4_1_0/core/org/apache/lucene/search/similarities/DFRSimilarity.html
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.DfrSimilarity.BasicModel">
            <summary>
            basic_model
            Possible values: be, d, g, if, in, ine and p
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.DfrSimilarity.AfterEffect">
            <summary>
            after_effect
            Possible values: no, b and l.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.DfrSimilarity.Normalization">
            <summary>
            normalization
            Possible values: no, h1, h2, h3 and z. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.IbSimilarity.#ctor(System.String)">
            <summary>
            nformation based model
            http://lucene.apache.org/core/4_1_0/core/org/apache/lucene/search/similarities/IBSimilarity.html
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.IbSimilarity.Distribution">
            <summary>
            distribution
            Possible values: ll and spl.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.IbSimilarity.Lambda">
            <summary>
            lambda
            Possible values: df and ttf. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.IbSimilarity.Normalization">
            <summary>
            normalization
            Possible values: no, h1, h2, h3 and z. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.LmDirichletSimilarity.#ctor(System.String)">
            <summary>
            LM Jelinek Mercer similarity
            http://lucene.apache.org/core/4_7_1/core/org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.html
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.LmJelinekMercerSimilarity.#ctor(System.String)">
            <summary>
            LM Jelinek Mercer similarity
            http://lucene.apache.org/core/4_7_1/core/org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.html
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.SimilarityCustom.LmJelinekMercerSimilarity.Lambda">
            <summary>
            The optimal value depends on both the collection and the query. 
            The optimal value is around 0.1 for title queries and 0.7 for long queries. Default to 0.1. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.BaseNGramTokenizer.MinGram">
            <summary>
            min_gram Minimum size in codepoints of a single n-gram
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.BaseNGramTokenizer.MaxGram">
            <summary>
             max_gram Maximum size in codepoints of a single n-gram
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.BaseNGramTokenizer.TokenChars">
            <summary>
            token_chars Characters classes to keep in the tokens, Elasticsearch will split on characters that don’t belong to any of these classes.
            [] (Keep all characters)
            token_chars accepts the following character classes:
              letter for example a, b, ï or 京
              digit for example 3 or 7
              whitespace for example " " or "\n"
              punctuation for example ! or "
              symbol for example $ or √ 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.ClassicTokenizer.#ctor(System.String)">
            <summary>
            A tokenizer of type classic providing grammar based tokenizer that is a good tokenizer for English language documents. 
            This tokenizer has heuristics for special treatment of acronyms, company names, email addresses, and internet host names. 
            However, these rules don’t always work, and the tokenizer doesn’t work well for most languages other than English.
            </summary>
            <param name="name">name of the custom tokenizer ToLower()</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.EdgeNGramTokenizer.#ctor(System.String)">
            <summary>
            A tokenizer of type edgeNGram.
            This tokenizer is very similar to nGram but only keeps n-grams which start at the beginning of a token.
            </summary>
            <param name="name">name of the custom tokenizer (ToLower()</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.KeywordTokenizer.#ctor(System.String)">
            <summary>
            A tokenizer of type keyword that emits the entire input as a single output.
            </summary>
            <param name="name">Name for the custom tokenizer</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.KeywordTokenizer.BufferSize">
            <summary>
            The maximum token length. If a token is seen that exceeds this length then it is discarded. Defaults to 255.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.NGramTokenizer.#ctor(System.String)">
            <summary>
            A tokenizer of type nGram.
            </summary>
            <param name="name">name of the custom tokenizer (ToLower()</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PathHierarchyTokenizer.#ctor(System.String)">
            <summary>
            The path_hierarchy tokenizer takes something like this:
            something/something/else
            And produces tokens:
            something
            something/something
            something/something/else
            </summary>
            <param name="name">custom name</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PathHierarchyTokenizer.Delimiter">
            <summary>
            delimiter 
            The character delimiter to use, defaults to /.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PathHierarchyTokenizer.Replacement">
            <summary>
            replacement
            An optional replacement character to use. Defaults to the delimiter.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PathHierarchyTokenizer.BufferSize">
            <summary>
            buffer_size
            The buffer size to use, defaults to 1024.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PathHierarchyTokenizer.Reverse">
            <summary>
            reverse
            Generates tokens in reverse order, defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PathHierarchyTokenizer.skip">
            <summary>
            skip
            Controls initial tokens to skip, defaults to 0.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PatternTokenizer.#ctor(System.String)">
            <summary>
            A tokenizer of type pattern that can flexibly separate text into terms via a regular expression. 
            </summary>
            <param name="name">name of custom tokenizer  ToLower()</param>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PatternTokenizer.Pattern">
             <summary>
             pattern The regular expression pattern, defaults to \W+.
             IMPORTANT: The regular expression should match the token separators, not the tokens themselves.
             
             Note that you may need to escape pattern string literal according to your client language rules. 
             For example, in many programming languages a string literal for \W+ pattern is written as "\\W+". 
             There is nothing special about pattern (you may have to escape other string literals as well); escaping pattern is common just 
             because it often contains characters that should be escaped.
             
             group set to -1 (the default) is equivalent to "split". Using group >= 0 selects the matching group as the token. For example, if you have:
            
             pattern = '([^']+)'
             group   = 0
             input   = aaa 'bbb' 'ccc'
            
             the output will be two tokens: 'bbb' and 'ccc' (including the ' marks). With the same input but using group=1, the output would be: bbb and ccc (no ' marks).
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PatternTokenizer.Flags">
            <summary>
            flags The regular expression flags.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.PatternTokenizer.Group">
            <summary>
            group Which group to extract into tokens. Defaults to -1 (split).
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.StandardTokenizer.#ctor(System.String)">
            <summary>
            The maximum token length. If a token is seen that exceeds this length then it is discarded. Defaults to 255.
            </summary>
            <param name="name">name of the custom tokenizer ToLower()</param>
        </member>
        <member name="M:ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.Tokenizers.UaxUrlEmailTokenizer.#ctor(System.String)">
            <summary>
            A tokenizer of type uax_url_email which works exactly like the standard tokenizer, but tokenizes emails and urls as single tokens.
            </summary>
            <param name="name">name of the custom tokenizer (ToLower()</param>
        </member>
        <member name="T:ElasticsearchCRUD.ContextAlias.AliasModel.AliasAddParameters">
            <summary>
            APIs in elasticsearch accept an index name when working against a specific index, and several indices when applicable. 
            The index aliases API allow to alias an index with a name, with all APIs automatically converting the alias name to the actual index name. 
            An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliases indices. 
            An alias can also be associated with a filter that will automatically be applied when searching, and routing values.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAlias.AliasModel.AliasAddParameters.Routing">
            <summary>
            It is possible to associate routing values with aliases. This feature can be used together with filtering aliases in order to avoid unnecessary shard operations.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextAlias.AliasModel.AliasAddParameters.Filter">
            <summary>
            An optional filter that can be associated with an alias.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextSearch.SearchModel.AggModel.Buckets.RangeBucket">
            <summary>
            "key":"2.0-1.5","from":2.0,"from_as_string":"2.0","to":1.5,"to_as_string":"1.5","doc_count":0
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextSearch.SearchModel.AggModel.ExtendedStatsMetricAggregationsResult.StdDeviationBounds">
            <summary>
            support from version 1.4.3
            The standard deviation and its bounds are displayed by default, but they are not always applicable to all data-sets. 
            Your data must be normally distributed for the metrics to make sense. The statistics behind standard deviations assumes normally distributed data, 
            so if your data is skewed heavily left or right, the value returned will be misleading.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextSearch.SearchModel.AggModel.GlobalBucketAggregationsResult">
            <summary>
            Defines a single bucket of all the documents within the search execution context. 
            This context is defined by the indices and the document types you’re searching on, but is not influenced by the search query itself.
            
            Note
            Global aggregators can only be placed as top level aggregators (it makes no sense to embed a global aggregator within another bucket aggregator)
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextSearch.SearchModel.AggModel.Buckets.SignificantTermsBucket">
            <summary>
            "key": "Bicycle theft",
            "score": 0.371235374214817,
            "bg_count": 66799
            "doc_count" : 33
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextSearch.SearchModel.AggModel.TermsBucketAggregationsResult.DocCountErrorUpperBound">
            <summary>
            doc_count_error_upper_bound
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextSearch.SearchModel.AggModel.TermsBucketAggregationsResult.SumOtherDocCount">
            <summary>
            sum_other_doc_count
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextSearch.SearchModel.SeachType">
             <summary>
             There are different execution paths that can be done when executing a distributed search. The distributed search operation needs to be scattered to all the relevant shards and 
             then all the results are gathered back. When doing scatter/gather type execution, there are several ways to do that, specifically with search engines.
            
             One of the questions when executing a distributed search is how much results to retrieve from each shard. For example, if we have 10 shards, 
             the 1st shard might hold the most relevant results from 0 till 10, with other shards results ranking below it. For this reason, when executing a request, 
             we will need to get results from 0 till 10 from all shards, sort them, and then return the results if we want to ensure correct results.
            
             Another question, which relates to the search engine, is the fact that each shard stands on its own. When a query is executed on a specific shard, 
             it does not take into account term frequencies and other search engine information from the other shards. If we want to support accurate ranking, 
             we would need to first gather the term frequencies from all shards to calculate global term frequencies, then execute the query on each shard using these globale frequencies.
            
             Also, because of the need to sort the results, getting back a large document set, or even scrolling it, 
             while maintaing the correct sorting behavior can be a very expensive operation. For large result set scrolling without sorting, the scan search type (explained below) is also available.
            
             Elasticsearch is very flexible and allows to control the type of search to execute on a per search request basis. 
             The type can be configured by setting the search_type parameter in the query string. 
             </summary>
        </member>
        <member name="F:ElasticsearchCRUD.ContextSearch.SearchModel.SeachType.query_and_fetch">
            <summary>
            The most naive (and possibly fastest) implementation is to simply execute the query on all relevant shards and return the results. 
            Each shard returns size results. Since each shard already returns size hits, this type actually returns size times number of shards results back to the caller.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.ContextSearch.SearchModel.SeachType.query_then_fetch">
            <summary>
            The query is executed against all shards, but only enough information is returned (not the document content). 
            The results are then sorted and ranked, and based on it, only the relevant shards are asked for the actual document content. 
            The return number of hits is exactly as specified in size, since they are the only ones that are fetched. 
            This is very handy when the index has a lot of shards (not replicas, shard id groups).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.ContextSearch.SearchModel.SeachType.dfs_query_and_fetch">
            <summary>
            Same as "Query And Fetch", except for an initial scatter phase which goes and computes the distributed term frequencies for more accurate scoring.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.ContextSearch.SearchModel.SeachType.count">
            <summary>
            A special search type that returns the count that matched the search request without any docs (represented in total_hits), and possibly, including facets as well. 
            In general, this is preferable to the count API as it provides more options.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters">
            <summary>
            This class is used to set routing or pretty search for the url parameters. All other options can be sent in the body
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters.SeachType">
            <summary>
            search_type
            The type of the search operation to perform. Can be dfs_query_then_fetch, dfs_query_and_fetch, query_then_fetch, query_and_fetch. 
            Defaults to query_then_fetch. See Search Type for more.  count and scan
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters.QueryCache">
            <summary>
            query_cache
            [1.4.0.Beta1] Added in 1.4.0.Beta1. Set to true or false to enable or disable the caching of search results for requests where ?search_type=count, 
            ie aggregations and suggestions. See Shard query cache. 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicDate">
            <summary>
            A basic formatter for a full date as four digit year, two digit month of year, and two digit day of month (yyyyMMdd).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicDateTime">
            <summary>
            A basic formatter that combines a basic date and time, separated by a T (yyyyMMdd’T'HHmmss.SSSZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicDateTimeNoMillis">
            <summary>
            A basic formatter that combines a basic date and time without millis, separated by a T (yyyyMMdd’T'HHmmssZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicOrdinalDate">
            <summary>
            A formatter for a full ordinal date, using a four digit year and three digit dayOfYear (yyyyDDD).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicOrdinalDateTime">
            <summary>
            A formatter for a full ordinal date and time, using a four digit year and three digit dayOfYear (yyyyDDD’T'HHmmss.SSSZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicOrdinalDateTimeNoMillis">
            <summary>
            A formatter for a full ordinal date and time without millis, using a four digit year and three digit dayOfYear (yyyyDDD’T'HHmmssZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicTime">
            <summary>
            A basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicTimeNoMillis">
            <summary>
            A basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset (HHmmssZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicTTime">
            <summary>
            A basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone off set prefixed by T ('T’HHmmss.SSSZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicTTimeNoMillis">
            <summary>
            A basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by T ('T’HHmmssZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicWeekDate">
            <summary>
            A basic formatter for a full date as four digit weekyear, two digit week of weekyear, and one digit day of week (xxxx’W'wwe).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicWeekDateTime">
            <summary>
            A basic formatter that combines a basic weekyear date and time, separated by a T (xxxx’W'wwe’T'HHmmss.SSSZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.BasicWeekDateTimeNoMillis">
            <summary>
            A basic formatter that combines a basic weekyear date and time without millis, separated by a T (xxxx’W'wwe’T'HHmmssZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.Date">
            <summary>
            A formatter for a full date as four digit year, two digit month of year, and two digit day of month (yyyy-MM-dd).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateHour">
            <summary>
            A formatter that combines a full date and two digit hour of day.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateHourMinute">
            <summary>
            A formatter that combines a full date, two digit hour of day, and two digit minute of hour.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateHourMinuteSecond">
            <summary>
            A formatter that combines a full date, two digit hour of day, two digit minute of hour, and two digit second of minute.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateHourMinuteSecondFraction">
            <summary>
            A formatter that combines a full date, two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (yyyy-MM-dd’T'HH:mm:ss.SSS).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateHourMinuteSecondMillis">
            <summary>
            A formatter that combines a full date, two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (yyyy-MM-dd’T'HH:mm:ss.SSS).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateOptionalTime">
            <summary>
            a generic ISO datetime parser where the date is mandatory and the time is optional.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.Date_Time">
            <summary>
            A formatter that combines a full date and time, separated by a T (yyyy-MM-dd’T'HH:mm:ss.SSSZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.DateTimeNoMillis">
            <summary>
            A formatter that combines a full date and time without millis, separated by a T (yyyy-MM-dd’T'HH:mm:ssZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.Hour">
            <summary>
            A formatter for a two digit hour of day.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.HourMinute">
            <summary>
            A formatter for a two digit hour of day and two digit minute of hour.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.HourMinuteSecond">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, and two digit second of minute.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.HourMinuteSecondFraction">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.HourMinuteSecondMillis">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.OrdinalDate">
            <summary>
            A formatter for a full ordinal date, using a four digit year and three digit dayOfYear (yyyy-DDD).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.OrdinalDateTime">
            <summary>
            A formatter for a full ordinal date and time, using a four digit year and three digit dayOfYear (yyyy-DDD’T'HH:mm:ss.SSSZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.OrdinalDateTimeNoMillis">
            <summary>
            A formatter for a full ordinal date and time without millis, using a four digit year and three digit dayOfYear (yyyy-DDD’T'HH:mm:ssZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.Time">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset (HH:mm:ss.SSSZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.TimeNoMillis">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset (HH:mm:ssZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.TTime">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset prefixed by T ('T’HH:mm:ss.SSSZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.TTimeNoMillis">
            <summary>
            A formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by T ('T’HH:mm:ssZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.WeekDate">
            <summary>
            A formatter for a full date as four digit weekyear, two digit week of weekyear, and one digit day of week (xxxx-'W’ww-e).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.WeekDateTime">
            <summary>
            A formatter that combines a full weekyear date and time, separated by a T (xxxx-'W’ww-e’T'HH:mm:ss.SSSZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.WeekDateTimeNoMillis">
            <summary>
            A formatter that combines a full weekyear date and time without millis, separated by a T (xxxx-'W’ww-e’T'HH:mm:ssZZ).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.WeekYear">
            <summary>
            A formatter for a four digit weekyear.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.WeekyearWeek">
            <summary>
            A formatter for a four digit weekyear and two digit week of weekyear.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.WeekyearWeekDay">
            <summary>
            A formatter for a four digit weekyear, two digit week of weekyear, and one digit day of week.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.Year">
            <summary>
            A formatter for a four digit year.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.YearMonth">
            <summary>
            A formatter for a four digit year and two digit month of year.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.DateTimeFormats.YearMonthDay">
            <summary>
            A formatter for a four digit year, two digit month of year, and two digit day of month.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.Point">
            <summary>
            A single geographic coordinate.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.LineString">
            <summary>
            An arbitrary line given two or more points.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.Polygon">
            <summary>
            A closed polygon whose first and last point must match, thus requiring n + 1 vertices to create an n-sided polygon and a minimum of 4 vertices.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.MultiPoint">
            <summary>
            An array of unconnected, but likely related points.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.MultiLineString">
            <summary>
            An array of separate linestrings.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.MultiPolygon">
            <summary>
            An array of separate polygons.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.GeometryCollection">
            <summary>
            A GeoJSON shape similar to the multi* shapes except that multiple types can coexist (e.g., a Point and a LineString).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.Envelope">
            <summary>
            A bounding rectangle, or envelope, specified by specifying only the top left and bottom right points.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.GeoModel.DefaultGeoShapes.Circle">
            <summary>
            A circle specified by a center point and radius with units, which default to METERS.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.GeoModel.GeoPoint">
             <summary>
             Indexed Fields
            
             The geo_point mapping will index a single field with the format of lat,lon. 
             The lat_lon option can be set to also index the .lat and .lon as numeric fields, and geohash can be set to true to also index .geohash value.
            
             A good practice is to enable indexing lat_lon as well, since both the geo distance and bounding box filters can either be executed using in memory checks, 
             or using the indexed lat lon values, and it really depends on the data set which one performs better. Note though,
              that indexed lat lon only make sense when there is a single geo point value for the field, and not multi values.
             
             Geohashes
            
             Geohashes are a form of lat/lon encoding which divides the earth up into a grid. Each cell in this grid is represented by a geohash string. 
             Each cell in turn can be further subdivided into smaller cells which are represented by a longer string. So the longer the geohash, the smaller (and thus more accurate) the cell is.
            
             Because geohashes are just strings, they can be stored in an inverted index like any other string, which makes querying them very efficient.
            
             If you enable the geohash option, a geohash “sub-field” will be indexed as, eg pin.geohash. The length of the geohash is controlled by the geohash_precision parameter, 
             which can either be set to an absolute length (eg 12, the default) or to a distance (eg 1km).
            
             More usefully, set the geohash_prefix option to true to not only index the geohash value, but all the enclosing cells as well. 
             For instance, a geohash of u30 will be indexed as [u,u3,u30]. This option can be used by the Geohash Cell Filter to find geopoints within a particular cell very efficiently.
             </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.GeoModel.GeoPoint.GuardLatitude(System.Double)">
            <summary>
            -90 to +90 for Latitude
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.GeoModel.GeoPoint.GuardLongitude(System.Double)">
            <summary>
            -180 to +180 for Longitude
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.GeoModel.GeoPoint.Add(System.Double)">
            <summary>
            This method cannot be used. Set the Longitude or the Latitude properties
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.GeoModel.GeoPoint.Latitude">
            <summary>
            -90 to +90 for Latitude
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.GeoModel.GeoPoint.Longitude">
            <summary>
            -180 to +180 for Longitude
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.GeoModel.GeoShapeCircle.Radius">
            <summary>
            The inner radius field is required. If not specified, then the units of the radius will default to METERS.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.GeoModel.GeoShapePolygon">
             <summary>
             A polygon is defined by a list of a list of points. The first and last points in each (outer) list must be the same (the polygon must be closed).
             The first array represents the outer boundary of the polygon, the other arrays represent the interior shapes ("holes"):
             
             IMPORTANT NOTE: GeoJSON does not mandate a specific order for vertices thus ambiguous polygons around the dateline and poles are possible. 
             To alleviate ambiguity the Open Geospatial Consortium (OGC) Simple Feature Access specification defines the following vertex ordering:
            
            	Outer Ring - Counterclockwise
            	Inner Ring(s) / Holes - Clockwise 
            
             For polygons that do not cross the dateline, vertex order will not matter in Elasticsearch. 
             For polygons that do cross the dateline, Elasticsearch requires vertex ordering to comply with the OGC specification. 
             Otherwise, an unintended polygon may be created and unexpected query/filter results will be returned.
            
             Elasticsearch will apply OGC standards to eliminate ambiguity resulting in a polygon that crosses the dateline.
             
             An orientation parameter can be defined when setting the geo_shape mapping (see the section called “Mapping Optionsedit”). 
             This will define vertex order for the coordinate list on the mapped geo_shape field. It can also be overridden on each document. 
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.BaseMetricAggregation">
            <summary>
            A single-value metrics aggregation that keeps track and returns the minimum value among numeric values extracted from the aggregated documents. 
            These values can be extracted either from specific numeric fields in the documents, or be generated by a provided script.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.CardinalityMetricAggregation">
            <summary>
            A single-value metrics aggregation that calculates an approximate count of distinct values. Values can be extracted either from specific fields in the document or generated by a script.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.CardinalityMetricAggregation.PrecisionThreshold">
            <summary>
            The precision_threshold options allows to trade memory for accuracy, and defines a unique count below which counts are expected to be close to accurate. Above this value, 
            counts might become a bit more fuzzy. The maximum supported value is 40000, thresholds above this number will have the same effect as a threshold of 40000. 
            Default value depends on the number of parent aggregations that multiple create buckets (such as terms or histograms). 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.CardinalityMetricAggregation.Rehash">
            <summary>
            If you computed a hash on client-side, stored it into your documents and want Elasticsearch to use them to compute counts using this hash function without rehashing values, 
            it is possible to specify rehash: false. Default value is true. Please note that the hash must be indexed as a long when rehash is false. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.ChidrenBucketAggregation">
            <summary>
            A special single bucket aggregation that enables aggregating from buckets on parent document types to buckets on child documents.
            
            This aggregation relies on the _parent field in the mapping. This aggregation has a single option:
            
            type - The what child type the buckets in the parent space should be mapped to. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation">
            <summary>
            A multi-bucket aggregation similar to the histogram except it can only be applied on date values. 
            Since dates are represented in elasticsearch internally as long values, it is possible to use the normal histogram on dates as well, 
            though accuracy will be compromised. The reason for this is in the fact that time based intervals are not fixed (think of leap years and on the number of days in a month). 
            For this reason, we need special support for time based data. From a functionality perspective, this histogram supports the same features as the normal histogram. 
            The main difference is that the interval can be specified by date/time expressions
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.MinDocCount">
            <summary>
            min_doc_count
            
            Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. 
            However, the shard does not have the information about the global document count available. 
            The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. 
            The min_doc_count criterion is only applied after merging local terms statistics of all shards. 
            In a way the decision to add the term as a candidate is made without being very certain about if the term will actually reach the required min_doc_count. 
            This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. 
            To avoid this, the shard_size parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.PreOffset">
            <summary>
            pre_offset
            Specific offsets can be provided for pre rounding and post rounding. 
            The pre_offset for pre rounding, and post_offset for post rounding. The format is the date time format (1h, 1d, etc…).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.PostOffset">
            <summary>
            post_offset
            Specific offsets can be provided for pre rounding and post rounding. 
            The pre_offset for pre rounding, and post_offset for post rounding. The format is the date time format (1h, 1d, etc…).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.PreZoneAdjustLargeInterval">
            <summary>
            pre_zone_adjust_large_interval
            Sometimes, we want to apply the same conversion to UTC we did above for hour also for day (and up) intervals. 
            We can set pre_zone_adjust_large_interval to true, which will apply the same conversion done for hour interval in the example, 
            to day and above intervals (it can be set regardless of the interval, but only kick in when using day and higher intervals).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.PostZone">
            <summary>
            post_zone
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.PreZone">
            <summary>
            pre_zone
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateHistogramBucketAggregation.TimeZone">
            <summary>
            time_zone
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateRangeBucketAggregation">
            <summary>
            A range aggregation that is dedicated for date values. 
            The main difference between this aggregation and the normal range aggregation is that the from and to values can be expressed in Date Math expressions, 
            and it is also possible to specify a date format by which the from and to response fields will be returned. 
            Note that this aggregration includes the from value and excludes the to value for each range.
            
            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html	
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.DateRangeBucketAggregation.Keyed">
            <summary>
            If this value is set, the buckets are returned with id classes. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.ExtendedStatsMetricAggregation">
            <summary>
            A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. 
            These values can be extracted either from specific numeric fields in the documents, or be generated by a provided script.
            
            The extended_stats aggregations is an extended version of the stats aggregation, 
            where additional metrics are added such as sum_of_squares, variance, std_deviation and std_deviation_bounds.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ExtendedStatsMetricAggregation.Sigma">
            <summary>
            support from version 1.4.3
            By default, the extended_stats metric will return an object called std_deviation_bounds, which provides an interval of plus/minus two standard deviations from the mean. 
            This can be a useful way to visualize variance of your data. If you want a different boundary.
            
            sigma can be any non-negative double, meaning you can request non-integer values such as 1.5. A value of 0 is valid, but will simply return the average for both upper and lower bounds.
            
            Note
            Standard Deviation and Bounds require normality
            
            The standard deviation and its bounds are displayed by default, but they are not always applicable to all data-sets. 
            Your data must be normally distributed for the metrics to make sense. The statistics behind standard deviations assumes normally distributed data, 
            so if your data is skewed heavily left or right, the value returned will be misleading.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeoDistanceBucketAggregation.Keyed">
            <summary>
            If this value is set, the buckets are returned with id classes. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeoDistanceBucketAggregation.DistanceType">
            <summary>
            distance_type
            How to compute the distance. Can either be sloppy_arc (default), arc (slighly more precise but significantly slower) or plane 
            (faster, but inaccurate on long distances and close to the poles).
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeoBoundsMetricAggregation">
            <summary>
            A metric aggregation that computes the bounding box containing all geo_point values for a field.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeohashGridBucketAggregation">
            <summary>
            A multi-bucket aggregation that works on geo_point fields and groups points into buckets that represent cells in a grid. 
            The resulting grid can be sparse and only contains cells that have matching data. Each cell is labeled using a geohash which is of user-definable precision.
            
            High precision geohashes have a long string length and represent cells that cover only a small area.
            
            Low precision geohashes have a short string length and represent cells that each cover a large area. 
            
            Geohashes used in this aggregation can have a choice of precision between 1 and 12.
            
            Warning
            The highest-precision geohash of length 12 produces cells that cover less than a square metre of land and so high-precision requests can be very costly in terms of RAM 
            and result sizes. Please see the example below on how to first filter the aggregation to a smaller geographic area before requesting high-levels of detail.
            
            The specified field must be of type geo_point (which can only be set explicitly in the mappings) and it can also hold an array of geo_point fields, 
            in which case all points will be taken into account during aggregation. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeohashGridBucketAggregation.Precision">
            <summary>
            _precision The string length of the geohashes used to define cells/buckets in the results. Defaults to 5. 
            
            1 : 5,009.4km x 4,992.6km
            2 : 1,252.3km x 624.1km
            3 : 156.5km x 156km
            4 : 39.1km x 19.5km
            5 : 4.9km x 4.9km
            6 : 1.2km x 609.4m
            7 : 152.9m x 152.4m
            8 : 38.2m x 19m
            9 : 4.8m x 4.8m
            10 : 1.2m x 59.5cm
            11 : 14.9cm x 14.9cm
            12 : 3.7cm x 1.9cm 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeohashGridBucketAggregation.Size">
            <summary>
            The size parameter can be set to define how many term buckets should be returned out of the overall terms list. 
            By default, the node coordinating the search process will request each shard to provide its own top size term buckets and once all shards respond, 
            it will reduce the results to the final list that will then be returned to the client. This means that if the number of unique terms is greater than size, 
            the returned list is slightly off and not accurate 
            (it could be that the term counts are slightly off and it could even be that a term that should have been in the top size buckets was not returned). 
            If set to 0, the size will be set to Integer.MAX_VALUE.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.GeohashGridBucketAggregation.ShardSize">
            <summary>
            shard_size
            The higher the requested size is, the more accurate the results will be, but also, the more expensive it will be to compute the final results 
            (both due to bigger priority queues that are managed on a shard level and due to bigger data transfers between the nodes and the client).
            
            The shard_size parameter can be used to minimize the extra work that comes with bigger requested size. When defined, 
            it will determine how many terms the coordinating node will request from each shard. Once all the shards responded, 
            the coordinating node will then reduce them to a final result which will be based on the size parameter - this way, 
            one can increase the accuracy of the returned terms and avoid the overhead of streaming a big list of buckets back to the client. 
            If set to 0, the shard_size will be set to Integer.MAX_VALUE
            
            Note
            shard_size cannot be smaller than size (as it doesn’t make much sense). When it is, elasticsearch will override it and reset it to be equal to size.
            It is possible to not limit the number of terms that are returned by setting size to 0. 
            Don’t use this on high-cardinality fields as this will kill both your CPU since terms need to be return sorted, and your network.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.HistogramBucketAggregation">
            <summary>
            A multi-bucket values source based aggregation that can be applied on numeric values extracted from the documents. 
            It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the documents have a field that holds a price (numeric), 
            we can configure this aggregation to dynamically build buckets with interval 5 (in case of price it may represent $5). 
            When the aggregation executes, the price field of every document will be evaluated and will be rounded down to its closest bucket - for example, 
            if the price is 32 and the bucket size is 5 then the rounding will yield 30 and thus the document will "fall" into the bucket that is associated withe the key 30
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.HistogramBucketAggregation.MinDocCount">
            <summary>
            min_doc_count
            
            Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. 
            However, the shard does not have the information about the global document count available. 
            The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. 
            The min_doc_count criterion is only applied after merging local terms statistics of all shards. 
            In a way the decision to add the term as a candidate is made without being very certain about if the term will actually reach the required min_doc_count. 
            This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. 
            To avoid this, the shard_size parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.HistogramBucketAggregation.Keyed">
            <summary>
            If this value is set, the buckets are returned with id classes. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.MissingBucketAggregation">
            <summary>
            A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value 
            (effectively, missing a field or having the configured NULL value set). 
            This aggregator will often be used in conjunction with other field data bucket aggregators (such as ranges) to return information for all the documents 
            that could not be placed in any of the other buckets due to missing field data values.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.NestedBucketAggregation">
            <summary>
            A special single bucket aggregation that enables aggregating nested documents.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.PercentileRanksMetricAggregation">
            <summary>
            A multi-value metrics aggregation that calculates one or more percentile ranks over numeric values extracted from the aggregated documents. 
            These values can be extracted either from specific numeric fields in the documents, or be generated by a provided script.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.RangeBucketAggregation`1.Keyed">
            <summary>
            If this value is set, the buckets are returned with id classes. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.ReverseNestedBucketAggregation">
            <summary>
            A special single bucket aggregation that enables aggregating on parent docs from nested documents. 
            Effectively this aggregation can break out of the nested block structure and link to other nested structures or the root document, 
            which allows nesting other aggregations that aren’t part of the nested object in a nested aggregation.
            
            The reverse_nested aggregation must be defined inside a nested aggregation.
            
            Options:
            
            path - Which defines to what nested object field should be joined back. The default is empty, which means that it joins back to the root / main document level. 
            The path cannot contain a reference to a nested object field that falls outside the nested aggregation’s nested structure a reverse_nested is in. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation">
            <summary>
            map_script
            Executed once per document collected. This is the only required script. If no combine_script is specified, the resulting state needs to be stored in an object named _agg.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.InitScript">
            <summary>
            init_script
            Executed prior to any collection of documents. Allows the aggregation to set up any initial state.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.CombineScript">
            <summary>
            combine_script
            Executed once on each shard after document collection is complete. Allows the aggregation to consolidate the state returned from each shard.
             If a combine_script is not provided the combine phase will return the aggregation variable.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.ReduceScript">
            <summary>
            reduce_script
            Executed once on the coordinating node after all shards have returned their results. The script is provided with access to a variable _aggs which is an array of the result of the combine_script on each shard. 
            If a reduce_script is not provided the reduce phase will return the _aggs variable.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.ReduceParams">
            <summary>
            reduce_params
            Optional. An object whose contents will be passed as variables to the reduce_script. 
            This can be useful to allow the user to control the behavior of the reduce phase. If this is not specified the variable will be undefined in the reduce_script execution.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.Lang">
            <summary>
            lang
            Optional. The script language used for the scripts. If this is not specified the default scripting language is used.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.InitScriptFile">
            <summary>
            init_script_file
            Optional. Can be used in place of the init_script parameter to provide the script using in a file.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.InitScriptId">
            <summary>
            init_script_id
            Optional. Can be used in place of the init_script parameter to provide the script using an indexed script.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.MapScriptFile">
            <summary>
            map_script_file
            Optional. Can be used in place of the map_script parameter to provide the script using in a file.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.MapScriptId">
            <summary>
            map_script_id
            Optional. Can be used in place of the map_script parameter to provide the script using an indexed script.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.CombineScriptFile">
            <summary>
            combine_script_file
            Optional. Can be used in place of the combine_script parameter to provide the script using in a file.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.CombineScriptId">
            <summary>
            combine_script_id
            Optional. Can be used in place of the combine_script parameter to provide the script using an indexed script.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.ReduceScriptFile">
            <summary>
            reduce_script_file
            Optional. Can be used in place of the reduce_script parameter to provide the script using in a file.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.ScriptedMetricAggregation.ReduceScriptId">
            <summary>
            reduce_script_id
            Optional. Can be used in place of the reduce_script parameter to provide the script using an indexed script. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation">
             <summary>
             Example use cases:
            
            	Suggesting "H5N1" when users search for "bird flu" in text
            	Identifying the merchant that is the "common point of compromise" from the transaction history of credit card owners reporting loss
            	Suggesting keywords relating to stock symbol $ATI for an automated news classifier
            	Spotting the fraudulent doctor who is diagnosing more than his fair share of whiplash injuries
            	Spotting the tire manufacturer who has a disproportionate number of blow-outs 
            
             In all these cases the terms being selected are not simply the most popular terms in a set. 
             They are the terms that have undergone a significant change in popularity measured between a foreground and background set. 
             If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user’s search results that is significant
              and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.
             Single-set analysise
            
             In the simplest case, the foreground set of interest is the search results matched by a query and the background set used for statistical comparisons is the index 
             or indices from which the results were gathered.
            
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation.Size">
            <summary>
            The size parameter can be set to define how many term buckets should be returned out of the overall terms list. 
            By default, the node coordinating the search process will request each shard to provide its own top size term buckets and once all shards respond, 
            it will reduce the results to the final list that will then be returned to the client. This means that if the number of unique terms is greater than size, 
            the returned list is slightly off and not accurate 
            (it could be that the term counts are slightly off and it could even be that a term that should have been in the top size buckets was not returned). 
            If set to 0, the size will be set to Integer.MAX_VALUE.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation.ShardSize">
            <summary>
            shard_size
            The higher the requested size is, the more accurate the results will be, but also, the more expensive it will be to compute the final results 
            (both due to bigger priority queues that are managed on a shard level and due to bigger data transfers between the nodes and the client).
            
            The shard_size parameter can be used to minimize the extra work that comes with bigger requested size. When defined, 
            it will determine how many terms the coordinating node will request from each shard. Once all the shards responded, 
            the coordinating node will then reduce them to a final result which will be based on the size parameter - this way, 
            one can increase the accuracy of the returned terms and avoid the overhead of streaming a big list of buckets back to the client. 
            If set to 0, the shard_size will be set to Integer.MAX_VALUE
            
            Note
            shard_size cannot be smaller than size (as it doesn’t make much sense). When it is, elasticsearch will override it and reset it to be equal to size.
            It is possible to not limit the number of terms that are returned by setting size to 0. 
            Don’t use this on high-cardinality fields as this will kill both your CPU since terms need to be return sorted, and your network.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation.MinDocCount">
            <summary>
            min_doc_count
            
            Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. 
            However, the shard does not have the information about the global document count available. 
            The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. 
            The min_doc_count criterion is only applied after merging local terms statistics of all shards. 
            In a way the decision to add the term as a candidate is made without being very certain about if the term will actually reach the required min_doc_count. 
            This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. 
            To avoid this, the shard_size parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation.ShardMinDocCount">
            <summary>
            shard_min_doc_count
            
            The parameter shard_min_doc_count regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the min_doc_count. 
            Terms will only be considered if their local shard frequency within the set is higher than the shard_min_doc_count. 
            If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), 
            then you can set the shard_min_doc_count parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required min_doc_count 
            even after merging the local counts. shard_min_doc_count is set to 0 per default and has no effect unless you explicitly set it.
            
            Note
            
            Setting min_doc_count=0 will also return buckets for terms that didn’t match any hit. 
            However, some of the returned terms which have a document count of zero might only belong to deleted documents, 
            so there is no warranty that a match_all query would find a positive document count for those terms
            
            Warning
            
            When NOT sorting on doc_count descending, high values of min_doc_count may return a number of buckets which is less than size because not enough data was gathered from the shards. 
            Missing buckets can be back by increasing shard_size. Setting shard_min_doc_count too high will cause terms to be filtered out on a shard level. 
            This value should be set much lower than min_doc_count/#shards.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation.ExecutionHint">
             <summary>
             execution_hint
             There are different mechanisms by which terms aggregations can be executed:
            
             by using field values directly in order to aggregate data per-bucket (map)
             by using ordinals of the field and preemptively allocating one bucket per ordinal value (global_ordinals)
             by using ordinals of the field and dynamically allocating one bucket per ordinal value (global_ordinals_hash)
             by using per-segment ordinals to compute counts and remap these counts to global counts using global ordinals (global_ordinals_low_cardinality) 
            
             Elasticsearch tries to have sensible defaults so this is something that generally doesn’t need to be configured.
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.SignificantTermsBucketAggregation.InformationRetrievalRetrieval">
             <summary>
             mutual_information, chi_square, gnd, jlh
             
             Mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1 can be used as significance score by adding the parameter
            
             "mutual_information": {
                  "include_negatives": true
              }
            
             Mutual information does not differentiate between terms that are descriptive for the subset or for documents outside the subset. 
             The significant terms therefore can contain terms that appear more or less frequent in the subset than outside the subset. 
             To filter out the terms that appear less often in the subset than in documents outside the subset, include_negatives can be set to false.
             
             Per default, the assumption is that the documents in the bucket are also contained in the background. 
             If instead you defined a custom background filter that represents a different set of documents that you want to compare to, set
             
             Roughly, mutual_information prefers high frequent terms even if they occur also frequently in the background. For example, 
             in an analysis of natural language text this might lead to selection of stop words. mutual_information is unlikely to select very rare terms like misspellings. 
             gnd prefers terms with a high co-occurence and avoids selection of stopwords. It might be better suited for synonym detection. 
             However, gnd has a tendency to select very rare terms that are, for example, a result of misspelling. chi_square and jlh are somewhat in-between.
             
             It is hard to say which one of the different heuristics will be the best choice as it depends on what the significant terms are used for 
             (see for example [Yang and Pedersen, "A Comparative Study on Feature Selection in Text Categorization", 1997]
             (http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf) 
             for a study on using significant terms for feature selection for text classification).
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.InformationRetrieval">
            <summary>
            mutual_information
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.StatsMetricAggregation">
            <summary>
            A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. 
            These values can be extracted either from specific numeric fields in the documents, or be generated by a provided script.
            
            The stats that are returned consist of: min, max, sum, count and avg.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.MinMetricAggregation">
            <summary>
            A single-value metrics aggregation that keeps track and returns the minimum value among numeric values extracted from the aggregated documents. 
            These values can be extracted either from specific numeric fields in the documents, or be generated by a provided script.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.FiltersBucketAggregation">
            <summary>
            A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation">
            <summary>
            A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation.Size">
            <summary>
            The size parameter can be set to define how many term buckets should be returned out of the overall terms list. 
            By default, the node coordinating the search process will request each shard to provide its own top size term buckets and once all shards respond, 
            it will reduce the results to the final list that will then be returned to the client. This means that if the number of unique terms is greater than size, 
            the returned list is slightly off and not accurate 
            (it could be that the term counts are slightly off and it could even be that a term that should have been in the top size buckets was not returned). 
            If set to 0, the size will be set to Integer.MAX_VALUE.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation.ShardSize">
            <summary>
            shard_size
            The higher the requested size is, the more accurate the results will be, but also, the more expensive it will be to compute the final results 
            (both due to bigger priority queues that are managed on a shard level and due to bigger data transfers between the nodes and the client).
            
            The shard_size parameter can be used to minimize the extra work that comes with bigger requested size. When defined, 
            it will determine how many terms the coordinating node will request from each shard. Once all the shards responded, 
            the coordinating node will then reduce them to a final result which will be based on the size parameter - this way, 
            one can increase the accuracy of the returned terms and avoid the overhead of streaming a big list of buckets back to the client. 
            If set to 0, the shard_size will be set to Integer.MAX_VALUE
            
            Note
            shard_size cannot be smaller than size (as it doesn’t make much sense). When it is, elasticsearch will override it and reset it to be equal to size.
            It is possible to not limit the number of terms that are returned by setting size to 0. 
            Don’t use this on high-cardinality fields as this will kill both your CPU since terms need to be return sorted, and your network.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation.MinDocCount">
            <summary>
            min_doc_count
            
            Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. 
            However, the shard does not have the information about the global document count available. 
            The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. 
            The min_doc_count criterion is only applied after merging local terms statistics of all shards. 
            In a way the decision to add the term as a candidate is made without being very certain about if the term will actually reach the required min_doc_count. 
            This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. 
            To avoid this, the shard_size parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation.ShardMinDocCount">
            <summary>
            shard_min_doc_count
            
            The parameter shard_min_doc_count regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the min_doc_count. 
            Terms will only be considered if their local shard frequency within the set is higher than the shard_min_doc_count. 
            If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), 
            then you can set the shard_min_doc_count parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required min_doc_count 
            even after merging the local counts. shard_min_doc_count is set to 0 per default and has no effect unless you explicitly set it.
            
            Note
            
            Setting min_doc_count=0 will also return buckets for terms that didn’t match any hit. 
            However, some of the returned terms which have a document count of zero might only belong to deleted documents, 
            so there is no warranty that a match_all query would find a positive document count for those terms
            
            Warning
            
            When NOT sorting on doc_count descending, high values of min_doc_count may return a number of buckets which is less than size because not enough data was gathered from the shards. 
            Missing buckets can be back by increasing shard_size. Setting shard_min_doc_count too high will cause terms to be filtered out on a shard level. 
            This value should be set much lower than min_doc_count/#shards.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation.CollectMode">
            <summary>
            Deferring calculation of child aggregations
            
            For fields with many unique terms and a small number of required results it can be more efficient to delay the calculation of child aggregations 
            until the top parent-level aggs have been pruned. Ordinarily, all branches of the aggregation tree are expanded in one depth-first pass and only then any pruning occurs. 
            In some rare scenarios this can be very wasteful and can hit memory constraints.
            
            When using breadth_first mode the set of documents that fall into the uppermost buckets are cached for subsequent replay so there is a memory overhead in doing this
            which is linear with the number of matching documents. 
            In most requests the volume of buckets generated is smaller than the number of documents that fall into them so the default depth_first collection mode is normally the best bet 
            but occasionally the breadth_first strategy can be significantly more efficient. 
            Currently elasticsearch will always use the depth_first collect_mode unless explicitly instructed to use breadth_first as in the above example. 
            Note that the order parameter can still be used to refer to data from a child aggregation when using the breadth_first setting 
            - the parent aggregation understands that this child aggregation will need to be called first before any of the other child aggregations.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TermsBucketAggregation.ExecutionHint">
             <summary>
             execution_hint
             There are different mechanisms by which terms aggregations can be executed:
            
             by using field values directly in order to aggregate data per-bucket (map)
             by using ordinals of the field and preemptively allocating one bucket per ordinal value (global_ordinals)
             by using ordinals of the field and dynamically allocating one bucket per ordinal value (global_ordinals_hash)
             by using per-segment ordinals to compute counts and remap these counts to global counts using global ordinals (global_ordinals_low_cardinality) 
            
             Elasticsearch tries to have sensible defaults so this is something that generally doesn’t need to be configured.
             </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Aggregations.ExecutionHint.map">
            <summary>
            should only be considered when very few documents match a query. Otherwise the ordinals-based execution modes are significantly faster. 
            By default, map is only used when running an aggregation on scripts, since they don’t have ordinals.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Aggregations.ExecutionHint.global_ordinals_low_cardinality">
            <summary>
            only works for leaf terms aggregations but is usually the fastest execution mode. 
            Memory usage is linear with the number of unique values in the field, so it is only enabled by default on low-cardinality fields.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Aggregations.ExecutionHint.global_ordinals">
            <summary>
             is the second fastest option, but the fact that it preemptively allocates buckets can be memory-intensive,
             especially if you have one or more sub aggregations. It is used by default on top-level terms aggregations.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Aggregations.ExecutionHint.global_ordinals_hash">
            <summary>
             on the contrary to global_ordinals and global_ordinals_low_cardinality allocates buckets dynamically 
            so memory usage is linear to the number of values of the documents that are part of the aggregation scope. It is used by default in inner aggregations.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TopHitsMetricAggregation.From">
            <summary>
            from
            The starting from index of the hits to return. Defaults to 0. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Aggregations.TopHitsMetricAggregation.Size">
            <summary>
            size
            The number of hits to return. Defaults to 10. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filter">
             <summary>
             As a general rule, filters should be used instead of queries:
            
             - for binary yes/no searches
             - for queries on exact values 
             
             Filters and Caching
            
             Filters can be a great candidate for caching. Caching the result of a filter does not require a lot of memory, 
             and will cause other queries executing against the same filter (same parameters) to be blazingly fast.
             
             Some filters already produce a result that is easily cacheable, and the difference between caching and not caching them is the act of placing the result in the cache or not. 
             These filters, which include the term, terms, prefix, and range filters, are by default cached and
             are recommended to use (compared to the equivalent query version) when the same filter (same parameters) will be used across multiple different queries 
             (for example, a range filter with age higher than 10).
             
             Other filters, usually already working with the field data loaded into memory, are not cached by default. Those filters are already very fast, 
             and the process of caching them requires extra processing in order to allow the filter result to be used with different queries than the one executed. 
             These filters, including the geo, and script filters are not cached by default.
             
             The last type of filters are those working with other filters. The and, not and or filters are not cached as they basically just manipulate the internal filters.
             
             All filters allow to set _cache element on them to explicitly control caching. They also allow to set _cache_key which will be used as the caching key for that filter. 
             This can be handy when using very large filters (like a terms filter with many elements in it).
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filtered">
             <summary>
             The filtered query is used to combine another query with any filter. Filters are usually faster than queries because:
            
             they don’t have to calculate the relevance _score for each document —  
             the answer is just a boolean “Yes, the document matches the filter” or “No, the document does not match the filter”.
             the results from most filters can be cached in memory, making subsequent executions faster. 
            
             Tip Exclude as many document as you can with a filter, then query just the documents that remain.
             
             If a query is not specified, it defaults to the match_all query. 
             This means that the filtered query can be used to wrap just a filter, so that it can be used wherever a query is expected.
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filtered.Query">
            <summary>
            defaults to a match_all  query if is not set
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filtered.Strategy">
             <summary>
             strategy
             
             The strategy parameter accepts the following options:
            
             leap_frog_query_first      - Look for the first document matching the query, and then alternatively advance the query and the filter to find common matches.
             leap_frog_filter_first     - Look for the first document matching the filter, and then alternatively advance the query and the filter to find common matches.
             leap_frog                  - Same as leap_frog_query_first.
             query_first                - If the filter supports random access, then search for documents using the query, and then consult the filter to check whether there is a match. Otherwise fall back to leap_frog_query_first.
             random_access_${threshold} - If the filter supports random access and if there is at least one matching document among the first threshold ones, then apply the filter first. Otherwise fall back to leap_frog_query_first. ${threshold} must be greater than or equal to 1.
             random_access_always       - Apply the filter first if it supports random access. Otherwise fall back to leap_frog_query_first.
            
             The default strategy is to use query_first on filters that are not advanceable such as geo filters and script filters, and random_access_100 on other filters.
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.AndFilter">
            <summary>
            A filter that matches documents using the AND boolean operator on other filters. Can be placed within queries that accept a filter.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.BoolFilter">
             <summary>
             A query that matches documents matching boolean combinations of other queries. The bool query maps to Lucene BooleanQuery. 
             It is built using one or more boolean clauses, each clause with a typed occurrence.
            {
            	"query":{
            		"bool" : {
            			"must" : [ 
            				{
            					"term" : { "details" : "different" }
            				},
            				{
            					"term" : { "details" : "data" }
            				}
            			],
            			"must_not" : [
            				{
            					"range" : {
            						"id" : { "from" : 7, "to" : 20 }
            					}
            				}
            			],
            			"should" : [
            				{
            					"term" : { "details" : "data" }
            				},
            				{
            					"term" : { "details" : "alone" }
            				}
            			]
            		}
            	}
            }
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.ExistsFilter">
            <summary>
            Returns documents that have at least one non-null value in the original field:
            Always cached
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.GeoBoundingBoxFilter">
            <summary>
            A filter allowing to filter hits based on a point location using a bounding box.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoBoundingBoxFilter.Type">
            <summary>
            type
            The type of the bounding box execution by default is set to memory, which means in memory checks if the doc falls within the bounding box range. 
            In some cases, an indexed option will perform faster (but note that the geo_point type must have lat and lon indexed in this case). 
            Note, when using the indexed option, multi locations per document field are not supported.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter">
            <summary>
            Filters documents that include only hits that exists within a specific distance from a geo point. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.#ctor(System.String,ElasticsearchCRUD.Model.GeoModel.GeoPoint,ElasticsearchCRUD.Model.Units.DistanceUnit,ElasticsearchCRUD.Model.Units.DistanceUnit)">
            <summary>
            Filters documents that include only hits that exists within a specific distance from a geo point. 
            </summary>
            <param name="field">name of the field used for the geo point</param>
            <param name="location">GeoPoint location</param>
            <param name="from">from in distance units</param>
            <param name="to">to in distance units</param>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.GreaterThanOrEqualTo">
            <summary>
            gte
            Greater-than or equal to
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.GreaterThan">
            <summary>
            gt
            Greater-than
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.LessThanOrEqualTo">
            <summary>
            lte
            Less-than or equal to
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.LessThan">
            <summary>
            lt
            Less-than
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.IncludeLower">
            <summary>
            include_lower
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceRangeFilter.IncludeUpper">
            <summary>
            include_upper
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceFilter">
            <summary>
            Filters documents that include only hits that exists within a specific distance from a geo point. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceFilter.#ctor(System.String,ElasticsearchCRUD.Model.GeoModel.GeoPoint,ElasticsearchCRUD.Model.Units.DistanceUnit)">
            <summary>
            Filters documents that include only hits that exists within a specific distance from a geo point. 
            </summary>
            <param name="field">name of the field used for the geo point</param>
            <param name="location">GeoPoint location</param>
            <param name="distance">The radius of the circle centred on the specified location. Points which fall into this circle are considered to be matches. 
            The distance can be specified in various units. See the section called “Distance Unitsedit”. </param>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceFilter.DistanceType">
            <summary>
            distance_type
            How to compute the distance. Can either be sloppy_arc (default), arc (slighly more precise but significantly slower) or plane 
            (faster, but inaccurate on long distances and close to the poles).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoDistanceFilter.OptimizeBbox">
            <summary>
            optimize_bbox
            Whether to use the optimization of first running a bounding box check before the distance check. Defaults to memory 
            which will do in memory checks. Can also have values of indexed to use indexed value check (make sure the geo_point type index lat lon in this case), 
            or none which disables bounding box optimization. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.IndicesFilter">
            <summary>
            The indices query can be used when executed across multiple indices, 
            allowing to have a query that executes only when executed on an index that matches a specific list of indices, 
            and another filter that executes when it is executed on an index that does not match the listed indices.
            
            The fields order is important: if the indices are provided before filter or no_match_query, 
            the related filters get parsed only against the indices that they are going to be executed on. 
            This is useful to avoid parsing queries when it is not necessary and prevent potential mapping errors.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.IndicesFilter.NoMatchFilter">
            <summary>
            no_match_filter
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.IndicesQuery.NoMatchQuery">
            <summary>
            no_match_query
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.TypeFilter">
            <summary>
            Filters documents matching the provided document / mapping type. 
            Note, this filter can work even when the _type field is not indexed (using the _uid field).
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.CommonTermsQuery">
            <summary>
            The common terms query is a modern alternative to stopwords which improves the precision and recall of search results (by taking stopwords into account), without sacrificing performance.
            
            The problem
            
            Every term in a query has a cost. A search for "The brown fox" requires three term queries, one for each of "the", "brown" and "fox", 
            all of which are executed against all documents in the index. The query for "the" is likely to match many documents and thus has a much smaller impact on relevance than the other two terms.
            
            Previously, the solution to this problem was to ignore terms with high frequency. By treating "the" as a stopword, 
            we reduce the index size and reduce the number of term queries that need to be executed.
            
            The problem with this approach is that, while stopwords have a small impact on relevance, they are still important. 
            If we remove stopwords, we lose precision, (eg we are unable to distinguish between "happy" and "not happy") 
            and we lose recall (eg text like "The The" or "To be or not to be" would simply not exist in the index).
            
            The solution
            
            The common terms query divides the query terms into two groups: more important (ie low frequency terms) and less important (ie high frequency terms 
            which would previously have been stopwords).
            
            First it searches for documents which match the more important terms. These are the terms which appear in fewer documents and have a greater impact on relevance.
            
            Then, it executes a second query for the less important terms — terms which appear frequently and have a low impact on relevance. 
            But instead of calculating the relevance score for all matching documents, it only calculates the _score for documents already matched by the first query. 
            In this way the high frequency terms can improve the relevance calculation without paying the cost of poor performance.
            
            If a query consists only of high frequency terms, then a single query is executed as an AND (conjunction) query, in other words all terms are required. 
            Even though each individual term will match many documents, the combination of terms narrows down the resultset to only the most relevant. 
            The single query can also be executed as an OR with a specific minimum_should_match, in this case a high enough value should probably be used.
            
            Terms are allocated to the high or low frequency groups based on the cutoff_frequency, which can be specified as an absolute frequency (>=1) or as a relative frequency (0.0 .. 1.0).
            
            Perhaps the most interesting property of this query is that it adapts to domain specific stopwords automatically. For example, 
            on a video hosting site, common terms like "clip" or "video" will automatically behave as stopwords without the need to maintain a manual list.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.CommonTermsQuery.LowFreqOperator">
            <summary>
            low_freq_operator
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.CommonTermsQuery.HighFreqOperator">
            <summary>
            high_freq_operator
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.CommonTermsQuery.MinimumShouldMatch">
            <summary>
            minimum_should_match
            This can be set or the high_freq, low_freq values. If minimum_should_match is set, the other values will be ignored
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DateTimeDecayBaseScoreFunction._origin">
            <summary>
            origin
            The point of origin used for calculating distance. Must be given as a number for numeric field, date for date fields and geo point for geo fields. 
            Required for geo and numeric field. For date fields the default is now. Date math (for example now-1h) is supported for origin.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DateTimeDecayBaseScoreFunction._scale">
            <summary>
            scale
            Required for all types. Defines the distance from origin at which the computed score will equal decay parameter. 
            For geo fields: Can be defined as number+unit (1km, 12m,…). Default unit is meters. For date fields: Can to be defined as a number+unit ("1h", "10d",…). 
            Default unit is milliseconds. For numeric field: Any number.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DateTimeDecayBaseScoreFunction.Offset">
            <summary>
            offset
            If an offset is defined, the decay function will only compute the decay function for documents with a distance greater that the defined offset. The default is 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DateTimeDecayBaseScoreFunction.Decay">
            <summary>
            decay
            The decay parameter defines how documents are scored at the distance given at scale. If no decay is defined, documents at the distance scale will be scored 0.5. 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DecayBaseScoreFunction`1._origin">
            <summary>
            origin
            The point of origin used for calculating distance. Must be given as a number for numeric field, date for date fields and geo point for geo fields. 
            Required for geo and numeric field. For date fields the default is now. Date math (for example now-1h) is supported for origin.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DecayBaseScoreFunction`1._scale">
            <summary>
            scale
            Required for all types. Defines the distance from origin at which the computed score will equal decay parameter. 
            For geo fields: Can be defined as number+unit (1km, 12m,…). Default unit is meters. For date fields: Can to be defined as a number+unit ("1h", "10d",…). 
            Default unit is milliseconds. For numeric field: Any number.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DecayBaseScoreFunction`1.Offset">
            <summary>
            offset
            If an offset is defined, the decay function will only compute the decay function for documents with a distance greater that the defined offset. The default is 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.DecayBaseScoreFunction`1.Decay">
            <summary>
            decay
            The decay parameter defines how documents are scored at the distance given at scale. If no decay is defined, documents at the distance scale will be scored 0.5. 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.GeoDecayBaseScoreFunction._origin">
            <summary>
            origin
            The point of origin used for calculating distance. Must be given as a number for numeric field, date for date fields and geo point for geo fields. 
            Required for geo and numeric field. For date fields the default is now. Date math (for example now-1h) is supported for origin.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.GeoDecayBaseScoreFunction._scale">
            <summary>
            scale
            Required for all types. Defines the distance from origin at which the computed score will equal decay parameter. 
            For geo fields: Can be defined as number+unit (1km, 12m,…). Default unit is meters. For date fields: Can to be defined as a number+unit ("1h", "10d",…). 
            Default unit is milliseconds. For numeric field: Any number.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.GeoDecayBaseScoreFunction.Offset">
            <summary>
            offset
            If an offset is defined, the decay function will only compute the decay function for documents with a distance greater that the defined offset. The default is 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.GeoDecayBaseScoreFunction.Decay">
            <summary>
            decay
            The decay parameter defines how documents are scored at the distance given at scale. If no decay is defined, documents at the distance scale will be scored 0.5. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FieldValueFactorFunction.#ctor(System.String)">
            <summary>
            The field_value_factor function allows you to use a field from a document to influence the score. It’s similar to using the script_score function, 
            however, it avoids the overhead of scripting. If used on a multi-valued field, only the first value of the field is used in calculations.
            
            Keep in mind that taking the log() of 0, or the square root of a negative number is an illegal operation, and an exception will be thrown. 
            Be sure to limit the values of the field with a range filter to avoid this, or use log1p and ln1p.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FieldValueFactorFunction.Factor">
            <summary>
            Optional factor to multiply the field value with, defaults to 1.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FieldValueFactorFunction.Modifier">
            <summary>
            modifier
            Modifier to apply to the field value, can be one of: none, log, log1p, log2p, ln, ln1p, ln2p, square, sqrt, or reciprocal. Defaults to none.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQuery">
            <summary>
            The function_score allows you to modify the score of documents that are retrieved by a query. 
            This can be useful if, for example, a score function is computationally expensive and it is sufficient to compute the score on a filtered set of documents.
            function_score provides the same functionality that custom_boost_factor, 
            custom_score and custom_filters_score provided but with additional capabilities such as distance and recency scoring
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQuery.ScoreMode">
            <summary>
            score_mode
            If no filter is given with a function this is equivalent to specifying "match_all": {}
            First, each document is scored by the defined functions. The parameter score_mode specifies how the computed scores are combined.
            
            Because scores can be on different scales (for example, between 0 and 1 for decay functions but arbitrary for field_value_factor) 
            and also because sometimes a different impact of functions on the score is desirable, the score of each function can be adjusted with a user defined weight ( [1.4.0.Beta1] 
            Added in 1.4.0.Beta1.). The weight can be defined per function in the functions array (example above) and is multiplied with the score computed by the respective function. 
            If weight is given without any other function declaration, weight acts as a function that simply returns the weight.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQuery.BoostMode">
            <summary>
            The new score can be restricted to not exceed a certain limit by setting the max_boost parameter. The default for max_boost is FLT_MAX.
            Finally, the newly computed score is combined with the score of the query. The parameter boost_mode defines how.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryBoostMode.multiply">
            <summary>
            query score and function score is multiplied (default)
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryBoostMode.replace">
            <summary>
            only function score is used, the query score is ignored
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryBoostMode.sum">
            <summary>
            query score and function score are added
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryBoostMode.avg">
            <summary>
            average
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryBoostMode.max">
            <summary>
            max of query score and function score
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryBoostMode.min">
            <summary>
            min of query score and function score 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryScoreMode.multiply">
            <summary>
            scores are multiplied (default)
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryScoreMode.sum">
            <summary>
            scores are summed
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryScoreMode.avg">
            <summary>
            scores are averaged
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryScoreMode.first">
            <summary>
            the first function that has a matching filter is applied
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryScoreMode.max">
            <summary>
            maximum score is used
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.FunctionQuery.FunctionScoreQueryScoreMode.min">
            <summary>
            minimum score is used 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.GeoShapePreIndexedFilter">
             <summary>
             The Filter also supports using a shape which has already been indexed in another index and/or index type. 
             This is particularly useful for when you have a pre-defined list of shapes which are useful to your application and you want to reference this using a logical name 
             (for example New Zealand) rather than having to provide their coordinates each time. In this situation it is only necessary to provide:
            
                id - The ID of the document that containing the pre-indexed shape.
                index - Name of the index where the pre-indexed shape is. Defaults to shapes.
                type - Index type where the pre-indexed shape is.
                path - The field specified as path containing the pre-indexed shape. Defaults to shape. 
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoShapePreIndexedFilter.Id">
            <summary>
            id - The ID of the document that containing the pre-indexed shape.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoShapePreIndexedFilter.Index">
            <summary>
            index - Name of the index where the pre-indexed shape is. Defaults to shapes.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoShapePreIndexedFilter.PreIndexedType">
            <summary>
            type - Index type where the pre-indexed shape is.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.GeoShapePreIndexedFilter.Path">
            <summary>
            path - The field specified as path containing the pre-indexed shape. Defaults to shape. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.HasChildFilter">
            <summary>
            The has_child filter accepts a query and the child type to run against, and results in parent documents that have child docs matching the query.
            
            The type is the child type to query against. The parent type to return is automatically detected based on the mappings.
            
            The way that the filter is implemented is by first running the child query, doing the matching up to the parent doc for each document matched.
            
            The has_child filter allows you to specify that a minimum and/or maximum number of children are required to match for the parent doc to be considered a match:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.HasChildFilter.MinChildren">
            <summary>
            min_children
            
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.HasChildFilter.MaxChildren">
            <summary>
            max_children
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.HasParentQuery">
            <summary>
            The has_parent query works the same as the has_parent filter, by automatically wrapping the filter with a constant_score 
            (when using the default score type). It has the same syntax as the has_parent filter.
            
            The has_parent also has scoring support. The supported score types are score or none. 
            The default is none and this ignores the score from the parent document. 
            The score is in this case equal to the boost on the has_parent query (Defaults to 1). 
            If the score type is set to score, then the score of the matching parent document is aggregated into the child documents belonging to the matching parent document. 
            The score type can be specified with the score_mode field inside the has_parent query
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.HasParentQuery.ScoreMode">
            <summary>
            score_mode
            score, none
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.HasParentFilter">
            <summary>
            The has_parent filter accepts a query and a parent type. The query is executed in the parent document space, which is specified by the parent type. 
            This filter returns child documents which associated parents have matched. 
            For the rest has_parent filter has the same options and works in the same manner as the has_child filter.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.IdsFilter">
            <summary>
            Filters documents that only have the provided ids. Note, this filter does not require the _id field to be indexed since it works using the _uid field.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.LimitFilter">
            <summary>
            A limit filter limits the number of documents (per shard) to execute on
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.MissingFilter.Existence">
            <summary>
            existence
            When the existence parameter is set to true (the default), the missing filter will include documents where the field has no values
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.MissingFilter.NullValue">
            <summary>
            null_value
            When the null_value parameter is set to true, the missing filter will include documents where the field contains a null value
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.OrFilter">
            <summary>
            A filter that matches documents using the OR boolean operator on other filters. Can be placed within queries that accept a filter.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.HasChildQuery">
            <summary>
            The has_child filter accepts a query and the child type to run against, and results in parent documents that have child docs matching the query.
            
            The type is the child type to query against. The parent type to return is automatically detected based on the mappings.
            
            The way that the filter is implemented is by first running the child query, doing the matching up to the parent doc for each document matched.
            
            The has_child filter allows you to specify that a minimum and/or maximum number of children are required to match for the parent doc to be considered a match:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.HasChildQuery.MinChildren">
            <summary>
            min_children
            
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.HasChildQuery.MaxChildren">
            <summary>
            max_children
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.HasChildQuery.ScoreMode">
            <summary>
            score_mode
            The score_mode allows to set how inner children matching affects scoring of parent. It defaults to avg, but can be sum, max and none.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery">
            <summary>
            More like this query find documents that are "like" provided text by running it against one or more fields.
            Additionally, More Like This can find documents that are "like" a set of chosen documents. 
            The syntax to specify one or more documents is similar to the Multi GET API, and supports the ids or docs array. 
            If only one document is specified, the query behaves the same as the More Like This API.
            
            Under the hood, more_like_this simply creates multiple should clauses in a bool query of interesting terms extracted from some provided text. 
            The interesting terms are selected with respect to their tf-idf scores. These are controlled by min_term_freq, min_doc_freq, and max_doc_freq. 
            The number of interesting terms is controlled by max_query_terms. 
            While the minimum number of clauses that must be satisfied is controlled by percent_terms_to_match. 
            The terms are extracted from like_text which is analyzed by the analyzer associated with the field, unless specified by analyzer. 
            There are other parameters, such as min_word_length, max_word_length or stop_words, to control what terms should be considered as interesting. 
            In order to give more weight to more interesting terms, 
            each boolean clause associated with a term could be boosted by the term tf-idf score times some boosting factor boost_terms. 
            When a search for multiple docs is issued, More Like This generates a more_like_this query per document field in fields. 
            These fields are specified as a top level parameter or within each doc.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.LikeText">
            <summary>
            like_text
            The text to find documents like it, required if ids or docs are not specified.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.Include">
            <summary>
            include
            When using ids or docs, specifies whether the documents should be included from the search. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.Exclude">
            <summary>
            exclude
            When using ids or docs, specifies whether the documents should be excluded from the search. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.PercentTermsToMatch">
            <summary>
            percent_terms_to_match
            From the generated query, the percentage of terms that must match (float value between 0 and 1). Defaults to 0.3 (30 percent).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.MinTermFreq">
            <summary>
            min_term_freq
            The frequency below which terms will be ignored in the source doc. The default frequency is 2.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.MaxQueryTerms">
            <summary>
            max_query_terms
            The maximum number of query terms that will be included in any generated query. Defaults to 25.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.Analyzer">
            <summary>
            analyzer
            The analyzer can be set to control which analyzer will perform the analysis process on the text. 
            It default to the field explicit mapping definition, or the default search analyzer, for example:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.StopWords">
            <summary>
            stop_words
            An array of stop words. Any word in this set is considered "uninteresting" and ignored. 
            Even if your Analyzer allows stopwords, you might want to tell the MoreLikeThis code to ignore them, 
            as for the purposes of document similarity it seems reasonable to assume that "a stop word is never interesting".
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.MinDocFreq">
            <summary>
            min_doc_freq
            The frequency at which words will be ignored which do not occur in at least this many docs. Defaults to 5.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.MaxDocFreq">
            <summary>
            max_doc_freq
            The maximum frequency in which words may still appear. Words that appear in more than this many docs will be ignored. Defaults to unbounded.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.MinWordLength">
            <summary>
            min_word_length
            The minimum word length below which words will be ignored. Defaults to 0.(Old name "min_word_len" is deprecated)
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.MaxWordLength">
            <summary>
            max_word_length
            The maximum word length above which words will be ignored. Defaults to unbounded (0). (Old name "max_word_len" is deprecated)
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MoreLikeThisQuery.BoostTerms">
            <summary>
            boost_terms
            Sets the boost factor to use when boosting terms. Defaults to deactivated (0). Any other value activates boosting with given boost factor.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.QueryFilter">
            <summary>
            Wraps any query to be used as a filter. Can be placed within queries that accept a filter.
            
            Keep in mind that once you wrap a query as a filter, it loses query features like highlighting and scoring because these are not features supported by filters.
            
            The result of the filter is not cached by default. The _cache can be set to true to cache the result of the filter. 
            This is handy when the same query is used on several (many) other queries. Note, the process of caching the first execution is higher when not caching 
            (since it needs to satisfy different queries).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.GreaterThanOrEqualTo">
            <summary>
            gte
            Greater-than or equal to
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.GreaterThan">
            <summary>
            gt
            Greater-than
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.LessThanOrEqualTo">
            <summary>
            lte
            Less-than or equal to
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.LessThan">
            <summary>
            lt
            Less-than
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.IncludeLower">
            <summary>
            include_lower
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.IncludeUpper">
            <summary>
            include_upper
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.RangeFilter.TimeZone">
            <summary>
            time_zone
            When applied on date fields the range filter accepts also a time_zone parameter. 
            The time_zone parameter will be applied to your input lower and upper bounds and will move them to UTC time based date
            
            if you give a date with a timezone explicitly defined and use the time_zone parameter, time_zone will be ignored. For example,
            setting gte to 2012-01-01T00:00:00+01:00 with "time_zone":"+10:00" will still use +01:00 time zone.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.RegExpFilter">
            <summary>
            The regexp query allows you to use regular expression term queries. See Regular expression syntax for details of the supported regular expression language. 
            The "term queries" in that first sentence means that Elasticsearch will apply the regexp to the terms produced by the tokenizer for that field, 
            and not to the original text of the field.
            
            Note: The performance of a regexp query heavily depends on the regular expression chosen. 
            Matching everything like .* is very slow as well as using lookaround regular expressions. 
            If possible, you should try to use a long prefix before your regular expression starts. Wildcard matchers like .*?+ will mostly lower performance.
            
            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Filters.ScriptFilter">
            <summary>
            Scripts are compiled and cached for faster execution. 
            If the same script can be used, just with different parameters provider, it is preferable to use the ability to pass parameters to the script itself
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Filters.TermsFilter.Execution">
            <summary>
            The way terms filter executes is by iterating over the terms provided and finding matches docs (loading into a bitset) and caching it. 
            Sometimes, we want a different execution model that can still be achieved by building more complex queries in the DSL, 
            but we can support them in the more compact model that terms filter provides.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Filters.ExecutionMode.plain">
            <summary>
            The default. Works as today. Iterates over all the terms, building a bit set matching it, and filtering. The total filter is cached.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Filters.ExecutionMode.fielddata">
            <summary>
            Generates a terms filters that uses the fielddata cache to compare terms. 
            This execution mode is great to use when filtering on a field that is already loaded into the fielddata cache from faceting, sorting, 
            or index warmers. When filtering on a large number of terms, this execution can be considerably faster than the other modes. 
            The total filter is not cached unless explicitly configured to do so.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Filters.ExecutionMode.bool">
            <summary>
            Generates a term filter (which is cached) for each term, and wraps those in a bool filter. 
            The bool filter itself is not cached as it can operate very quickly on the cached term filters.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Filters.ExecutionMode.and">
            <summary>
            Generates a term filter (which is cached) for each term, and wraps those in an and filter. The and filter itself is not cached.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Filters.ExecutionMode.or">
            <summary>
            Generates a term filter (which is cached) for each term, and wraps those in an or filter. The or filter itself is not cached. Generally, 
            the bool execution mode should be preferred. 
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.SearchModel.Queries.IdsQuery.#ctor(System.Collections.Generic.List{System.Object})">
            <summary>
            Filters documents that only have the provided ids. Note, this filter does not require the _id field to be indexed since it works using the _uid field.
            </summary>
            <param name="ids"></param>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.NestedQuery">
            <summary>
            Nested query allows to query nested objects / docs (see nested mapping). 
            The query is executed against the nested objects / docs as if they were indexed as separate docs (they are, internally) 
            and resulting in the root parent doc (or parent nested mapping). 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.NestedQuery.ScoreMode">
            <summary>
            score_mode
            The score_mode allows to set how inner children matching affects scoring of parent. It defaults to avg, but can be sum, max and none.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery">
            <summary>
            Query search which can do loads; see the documentation:
            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.DefaultField">
            <summary>
            default_field
            The default field for query terms if no prefix field is specified. Defaults to the index.query.default_field index settings, which in turn defaults to _all.
            
            When not explicitly specifying the field to search on in the query string syntax, the index.query.
            default_field will be used to derive which field to search on. It defaults to _all field.
            
            So, if _all field is disabled, it might make sense to change it to set a different default fie
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.DefaultOperator">
            <summary>
            default_operator
            The default operator used if no explicit operator is specified. For example, with a default operator of OR, the query capital of Hungary is translated to capital OR of OR Hungary, 
            and with default operator of AND, the same query is translated to capital AND of AND Hungary. The default value is OR.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.Analyzer">
            <summary>
            analyzer
            The analyzer can be set to control which analyzer will perform the analysis process on the text. 
            It default to the field explicit mapping definition, or the default search analyzer, for example:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.AllowLeadingWildcard">
            <summary>
            allow_leading_wildcard
            When set, * or ? are allowed as the first character. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.LowercaseExpandedTerms">
            <summary>
            lowercase_expanded_terms
            Whether terms of wildcard, prefix, fuzzy, and range queries are to be automatically lower-cased or not (since they are not analyzed). Default it true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.EnablePositionIncrements">
            <summary>
            enable_position_increments
            Set to true to enable position increments in result queries. Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.FuzzyMaxExpansions">
            <summary>
            fuzzy_max_expansions
            Controls the number of terms fuzzy queries will expand to. Defaults to 50
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.Fuzziness">
            <summary>
            fuzziness
            The minimum similarity of the term variants. Defaults to 0.5. See the section called Fuzziness
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.MinimumShouldMatch">
             <summary>
             minimum_should_match
             The minimum_should_match parameter possible values:
             
             Integer : Indicates a fixed value regardless of the number of optional clauses.
             Negative integer : Indicates that the total number of optional clauses, minus this number should be mandatory.
             Percentage 75% : Indicates that this percent of the total number of optional clauses are necessary. The number computed from the percentage is rounded down and used as the minimum.
             Negative percentage -25% Indicates that this percent of the total number of optional clauses can be missing.
              The number computed from the percentage is rounded down, before being subtracted from the total to determine the minimum.
             Combination : A positive integer, followed by the less-than symbol, followed by any of the previously mentioned specifiers is a conditional specification.
              It indicates that if the number of optional clauses is equal to (or less than) the integer, they are all required, but if it’s greater than the integer,
              the specification applies. In this example: if there are 1 to 3 clauses they are all required, but for 4 or more clauses only 90% are required.
             Multiple combinations :  Multiple conditional specifications can be separated by spaces, each one only being valid for numbers greater than the one before it.
              In this example: if there are 1 or 2 clauses both are required, if there are 3-9 clauses all but 25% are required, and if there are more than 9 clauses,
              all but three are required.
            
             NOTE:
             When dealing with percentages, negative values can be used to get different behavior in edge cases. 75% and -25% mean the same thing when dealing with 4 clauses, 
             but when dealing with 5 clauses 75% means 3 are required, but -25% means 4 are required.
            
             If the calculations based on the specification determine that no optional clauses are needed, 
             the usual rules about BooleanQueries still apply at search time (a BooleanQuery containing no required clauses must still match at least one optional clause)
            
             No matter what number the calculation arrives at, a value greater than the number of optional clauses, or a value less than 1 will never be used. 
             (ie: no matter how low or how high the result of the calculation result is, the minimum number of required matches will never be lower than 1 or greater than the number of clauses.
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.FuzzyPrefixLength">
            <summary>
            fuzzy_prefix_length
            Set the prefix length for fuzzy queries. Default is 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.PhraseSlop">
            <summary>
            phrase_slop
            Sets the default slop for phrases. If zero, then exact phrase matches are required. Default value is 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.AnalyzeWildcard">
            <summary>
            analyze_wildcard
            By default, wildcards terms in a query string are not analyzed. By setting this value to true, a best effort will be made to analyze those as well.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.AutoGeneratePhraseQueries">
            <summary>
            auto_generate_phrase_queries
            Default to false
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.Lenient">
            <summary>
            lenient
            If set to true will cause format based failures (like providing text to a numeric field) to be ignored.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.Locale">
            <summary>
            _locale
            Locale that should be used for string conversions. Defaults to ROOT.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.UseDisMax">
            <summary>
            use_dis_max
            Should the queries be combined using dis_max (set it to true), or a bool query (set it to false). Defaults to true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.QueryStringQuery.TieBreaker">
            <summary>
            tie_breaker
            When using dis_max, the disjunction max tie breaker. Defaults to 0
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.RegExpQuery">
            <summary>
            The regexp query allows you to use regular expression term queries. See Regular expression syntax for details of the supported regular expression language. 
            The "term queries" in that first sentence means that Elasticsearch will apply the regexp to the terms produced by the tokenizer for that field, 
            and not to the original text of the field.
            
            Note: The performance of a regexp query heavily depends on the regular expression chosen. 
            Matching everything like .* is very slow as well as using lookaround regular expressions. 
            If possible, you should try to use a long prefix before your regular expression starts. Wildcard matchers like .*?+ will mostly lower performance.
            
            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery">
             <summary>
             A query that uses the SimpleQueryParser to parse its context. Unlike the regular query_string query, 
             the simple_query_string query will never throw an exception, and discards invalid parts of the query
             
             The simple_query_string supports the following special characters:
            
             + signifies AND operation
             | signifies OR operation
             - negates a single token
             " wraps a number of tokens to signify a phrase for searching
             * at the end of a term signifies a prefix query
             ( and ) signify precedence
             ~N after a word signifies edit distance (fuzziness)
             ~N after a phrase signifies slop amount 
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery.DefaultOperator">
            <summary>
            default_operator
            The default operator used if no explicit operator is specified. For example, with a default operator of OR, the query capital of Hungary is translated to capital OR of OR Hungary, 
            and with default operator of AND, the same query is translated to capital AND of AND Hungary. The default value is OR.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery.Analyzer">
            <summary>
            analyzer
            The analyzer can be set to control which analyzer will perform the analysis process on the text. 
            It default to the field explicit mapping definition, or the default search analyzer, for example:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery.LowercaseExpandedTerms">
            <summary>
            lowercase_expanded_terms
            Whether terms of wildcard, prefix, fuzzy, and range queries are to be automatically lower-cased or not (since they are not analyzed). Default it true.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery.Lenient">
            <summary>
            lenient
            If set to true will cause format based failures (like providing text to a numeric field) to be ignored.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery.Locale">
            <summary>
            _locale
            Locale that should be used for string conversions. Defaults to ROOT.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SimpleQueryStringQuery.Fields">
            <summary>
            fields
            The fields to perform the parsed query against. Defaults to the index.query.default_field index settings, which in turn defaults to _all.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.SpanFirstQuery">
            <summary>
            Matches spans near the beginning of a field. The span first query maps to Lucene SpanFirstQuery.
            The match clause can be any other span type query. The end controls the maximum end position permitted in a match.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.SpanMultiQuery">
            <summary>
            The span_multi query allows you to wrap a multi term query (one of fuzzy, prefix, term range or regexp query) as a span query, so it can be nested. Example:
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNearQuery">
            <summary>
            Matches spans which are near one another. 
            One can specify slop, the maximum number of intervening unmatched positions, as well as whether matches are required to be in-order. 
            The span near query maps to Lucene SpanNearQuery. 
            
            The clauses element is a list of one or more other span type queries and the slop controls the maximum number of intervening unmatched positions permitted.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNearQuery.InOrder">
            <summary>
            in_order
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNearQuery.CollectPayloads">
            <summary>
            collect_payloads
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNotQuery.#ctor(ElasticsearchCRUD.Model.SearchModel.Queries.ISpanQuery,ElasticsearchCRUD.Model.SearchModel.Queries.ISpanQuery)">
            <summary>
            Removes matches which overlap with another span query. The span not query maps to Lucene SpanNotQuery.
            The include and exclude clauses can be any span type query. The include clause is the span query whose matches are filtered, 
            and the exclude clause is the span query whose matches must not overlap those returned.
            
            In the above example all documents with the term hoya are filtered except the ones that have la preceeding them.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNotQuery.Pre">
            <summary>
            pre
            If set the amount of tokens before the include span can’t have overlap with the exclude span.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNotQuery.Post">
            <summary>
            post
            If set the amount of tokens after the include span can’t have overlap with the exclude span.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.SpanNotQuery.Dist">
            <summary>
            dist
            If set the amount of tokens from within the include span can’t have overlap with the exclude span. Equivalent of setting both pre and post. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.SpanOrQuery">
            <summary>
            Matches the union of its span clauses. The span or query maps to Lucene SpanOrQuery.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.SpanTermQuery">
            <summary>
            Matches spans containing a term. The span term query maps to Lucene SpanTermQuery. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.TopChildrenQuery">
            <summary>
            The top_children query runs the child query with an estimated hits size, and out of the hit docs, aggregates it into parent docs. 
            If there aren’t enough parent docs matching the requested from/size search request, then it is run again with a wider (more hits) search.
            
            The top_children also provide scoring capabilities, with the ability to specify max, sum or avg as the score type.
            
            One downside of using the top_children is that if there are more child docs matching the required hits when executing the child query, 
            then the total_hits result of the search response will be incorrect.
            
            How many hits are asked for in the first child query run is controlled using the factor parameter (defaults to 5). For example, when asking for 10 parent docs (with from set to 0), 
            then the child query will execute with 50 hits expected. If not enough parents are found (in our example 10), 
            and there are still more child docs to query, then the child search hits are expanded by multiplying by the incremental_factor (defaults to 2).
            
            The required parameters are the query and type (the child type to execute the query on).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.TopChildrenQuery.Factor">
            <summary>
            _factor
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.TopChildrenQuery.IncrementalFactor">
            <summary>
            incremental_factor
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Sorting.SortGeoDistance.Mode">
            <summary>
            mode
            Elasticsearch supports sorting by array or multi-valued fields. 
            The mode option controls what array value is picked for sorting the document it belongs to. The mode option can have the following values:
            SortMode enum: min, max, avg
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortModeGeo.min">
            <summary>
            Pick the lowest value.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortModeGeo.max">
            <summary>
            Pick the highest value.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortModeGeo.avg">
            <summary>
            Use the average of all values as sort value. Only applicable for number based array fields. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.BoolQuery">
             <summary>
             A query that matches documents matching boolean combinations of other queries. The bool query maps to Lucene BooleanQuery. 
             It is built using one or more boolean clauses, each clause with a typed occurrence.
            {
            	"query":{
            		"bool" : {
            			"must" : [ 
            				{
            					"term" : { "details" : "different" }
            				},
            				{
            					"term" : { "details" : "data" }
            				}
            			],
            			"must_not" : [
            				{
            					"range" : {
            						"id" : { "from" : 7, "to" : 20 }
            					}
            				}
            			],
            			"should" : [
            				{
            					"term" : { "details" : "data" }
            				},
            				{
            					"term" : { "details" : "alone" }
            				}
            			],
            			"minimum_should_match" : 1,
            			"boost" : 3.0
            		}
            	}
            }
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.BoolQuery.MinimumShouldMatch">
             <summary>
             minimum_should_match
             The minimum_should_match parameter possible values:
             
             Integer : Indicates a fixed value regardless of the number of optional clauses.
             Negative integer : Indicates that the total number of optional clauses, minus this number should be mandatory.
             Percentage 75% : Indicates that this percent of the total number of optional clauses are necessary. The number computed from the percentage is rounded down and used as the minimum.
             Negative percentage -25% Indicates that this percent of the total number of optional clauses can be missing.
              The number computed from the percentage is rounded down, before being subtracted from the total to determine the minimum.
             Combination : A positive integer, followed by the less-than symbol, followed by any of the previously mentioned specifiers is a conditional specification.
              It indicates that if the number of optional clauses is equal to (or less than) the integer, they are all required, but if it’s greater than the integer,
              the specification applies. In this example: if there are 1 to 3 clauses they are all required, but for 4 or more clauses only 90% are required.
             Multiple combinations :  Multiple conditional specifications can be separated by spaces, each one only being valid for numbers greater than the one before it.
              In this example: if there are 1 or 2 clauses both are required, if there are 3-9 clauses all but 25% are required, and if there are more than 9 clauses,
              all but three are required.
            
             NOTE:
             When dealing with percentages, negative values can be used to get different behavior in edge cases. 75% and -25% mean the same thing when dealing with 4 clauses, 
             but when dealing with 5 clauses 75% means 3 are required, but -25% means 4 are required.
            
             If the calculations based on the specification determine that no optional clauses are needed, 
             the usual rules about BooleanQueries still apply at search time (a BooleanQuery containing no required clauses must still match at least one optional clause)
            
             No matter what number the calculation arrives at, a value greater than the number of optional clauses, or a value less than 1 will never be used. 
             (ie: no matter how low or how high the result of the calculation result is, the minimum number of required matches will never be lower than 1 or greater than the number of clauses.
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.BoolQuery.DisableCoord">
            <summary>
            disable_coord
            The bool query also supports disable_coord parameter (defaults to false). 
            Basically the coord similarity computes a score factor based on the fraction of all query terms that a document contains. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.BoostingQuery">
            <summary>
            The boosting query can be used to effectively demote results that match a given query. Unlike the "NOT" clause in bool query, 
            this still selects documents that contain undesirable terms, but reduces their overall score.
            
            {
             "boosting" : {
            	"positive" : {
            		"term" : {
            			"field1" : "value1"
            		}
            	},
            	"negative" : {
            		"term" : {
            			"field2" : "value2"
            		}
            	},
            	"negative_boost" : 0.2
             }
            }
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.BoostingQuery.Positive">
            <summary>
            positive
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.BoostingQuery.NegativeBoost">
            <summary>
            negative_boost
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.ConstantScoreQuery">
            <summary>
            A query that wraps a filter or another query and simply returns a constant score equal to the query boost for every document in the filter. 
            Maps to Lucene ConstantScoreQuery.
            
            The filter object can hold only filter elements, not queries. Filters can be much faster compared to queries since they don’t perform any scoring, especially when they are cached.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.ConstantScoreQuery.Query">
            <summary>
            positive
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.DisMaxQuery">
             <summary>
             A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum score for that document as produced by any subquery, 
             plus a tie breaking increment for any additional matching subqueries.
             
             This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be combined equivalently into a single search field). 
             We want the primary score to be the one associated with the highest boost, not the sum of the field scores (as Boolean Query would give). If the query is "albino elephant" 
             this ensures that "albino" matching one field and "elephant" matching another gets a higher score than "albino" matching both fields. 
             To get this result, use both Boolean Query and DisjunctionMax Query: for each term a DisjunctionMaxQuery searches for it in each field, 
             while the set of these DisjunctionMaxQuery’s is combined into a BooleanQuery.
             
             The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that include this term in only the best of those multiple fields,
             without confusing this with the better case of two different terms in the multiple fields.The default tie_breaker is 0.0.
             
             This query maps to Lucene DisjunctionMaxQuery
             
             {
            	"dis_max" : {
            		"tie_breaker" : 0.7,
            		"boost" : 1.2,
            		"queries" : [
            			{
            				"term" : { "age" : 34 }
            			},
            			{
            				"term" : { "age" : 35 }
            			}
            		]
            	}
            }
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.DisMaxQuery.TieBreaker">
            <summary>
            tie_breaker
            By default, each per-term blended query will use the best score returned by any field in a group, then these scores are added together to give the final score. 
            The tie_breaker parameter can change the default behaviour of the per-term blended queries. It accepts:
            
            0.0 Take the single best score out of (eg) first_name:will and last_name:will (default)
            1.0 Add together the scores for (eg) first_name:will and last_name:will
            0.0 between 1.0 Take the single best score plus tie_breaker multiplied by each of the scores from other matching fields. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisFieldQuery">
            <summary>
            The fuzzy_like_this_field query is the same as the fuzzy_like_this query, except that it runs against a single field. 
            It provides nicer query DSL over the generic fuzzy_like_this query, and support typed fields query 
            (automatically wraps typed fields with type filter to match only on the specific type).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisFieldQuery.IgnoreTf">
            <summary>
            ignore_tf
            Should term frequency be ignored. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisFieldQuery.MaxQueryTerms">
            <summary>
            max_query_terms
            The maximum number of query terms that will be included in any generated query. Defaults to 25.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisFieldQuery.Fuzziness">
            <summary>
            fuzziness
            The minimum similarity of the term variants. Defaults to 0.5. See the section called Fuzziness
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisFieldQuery.PrefixLength">
            <summary>
            prefix_length
            Length of required common prefix on variant terms. Defaults to 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisFieldQuery.Analyzer">
            <summary>
            analyzer
            The analyzer can be set to control which analyzer will perform the analysis process on the text. 
            It default to the field explicit mapping definition, or the default search analyzer, for example:
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisQuery">
            <summary>
            Fuzzy like this query find documents that are "like" provided text by running it against one or more fields
            
            Fuzzifies ALL terms provided as strings and then picks the best n differentiating terms. 
            In effect this mixes the behaviour of FuzzyQuery and MoreLikeThis but with special consideration of fuzzy scoring factors. 
            This generally produces good results for queries where users may provide details in a number of fields and have no knowledge of boolean query syntax 
            and also want a degree of fuzzy matching and a fast query.
            
            For each source term the fuzzy variants are held in a BooleanQuery with no coord factor (because we are not looking for matches on multiple variants in any one doc). 
            Additionally, a specialized TermQuery is used for variants and does not use that variant term’s IDF because this would favor rarer terms, such as misspellings. 
            Instead, all variants use the same IDF ranking (the one for the source query term) and this is factored into the variant’s boost. 
            If the source query term does not exist in the index the average IDF of the variants is used.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisQuery.IgnoreTf">
            <summary>
            ignore_tf
            Should term frequency be ignored. Defaults to false.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisQuery.MaxQueryTerms">
            <summary>
            max_query_terms
            The maximum number of query terms that will be included in any generated query. Defaults to 25.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisQuery.Fuzziness">
            <summary>
            fuzziness
            The minimum similarity of the term variants. Defaults to 0.5. See the section called Fuzziness
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisQuery.PrefixLength">
            <summary>
            prefix_length
            Length of required common prefix on variant terms. Defaults to 0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyLikeThisQuery.Analyzer">
            <summary>
            analyzer
            The analyzer can be set to control which analyzer will perform the analysis process on the text. 
            It default to the field explicit mapping definition, or the default search analyzer, for example:
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyQuery">
            <summary>
            The fuzzy query uses similarity based on Levenshtein edit distance for string fields, and a +/- margin on numeric and date fields.
            String fields 
            The fuzzy query generates all possible matching terms that are within the maximum edit distance specified in fuzziness and 
            then checks the term dictionary to find out which of those generated terms actually exist in the index.
            
            Warning: this query can be very heavy if prefix_length and max_expansions are both set to 0. This could cause every term in the index to be examined!
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyQuery.MaxExpansions">
            <summary>
            max_expansions
            The maximum number of terms that the fuzzy query will expand to. Defaults to 50. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyQuery.Fuzziness">
            <summary>
            fuzziness
            The minimum similarity of the term variants. Defaults to 0.5. See the section called Fuzziness
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.FuzzyQuery.PrefixLength">
            <summary>
            prefix_length
            Length of required common prefix on variant terms. Defaults to 0.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.MatchQuery">
            <summary>
            A family of match queries that accept text/numerics/dates, analyzes it, and constructs a query out of it. For example:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchBase.ZeroTermsQuery">
            <summary>
            zero_terms_query
            If the analyzer used removes all tokens in a query like a stop filter does, the default behavior is to match no documents at all. 
            In order to change that the zero_terms_query option can be used, which accepts none (default) and all which corresponds to a match_all query.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchBase.CutoffFrequency">
            <summary>
            cutoff_frequency range [0..1) 
            
            The match query supports a cutoff_frequency that allows specifying an absolute or relative document frequency where high frequency terms 
            are moved into an optional subquery and are only scored 
            if one of the low frequency (below the cutoff) terms in the case of an or operator or all of the low frequency terms in the case of an and operator match.
            
            This query allows handling stopwords dynamically at runtime, is domain independent and doesn’t require on a stopword file. 
            It prevent scoring / iterating high frequency terms and only takes the terms into account if a more significant / lower frequency terms match a document. 
            Yet, if all of the query terms are above the given cutoff_frequency the query is automatically transformed into a pure conjunction (and) query to ensure fast execution.
            
            The cutoff_frequency can either be relative to the number of documents in the index if in the range [0..1) or absolute if greater or equal to 1.0.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchBase.Analyzer">
            <summary>
            analyzer
            The analyzer can be set to control which analyzer will perform the analysis process on the text. 
            It default to the field explicit mapping definition, or the default search analyzer, for example:
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchBase.Fuzziness">
            <summary>
            fuzziness
            The minimum similarity of the term variants. Defaults to 0.5. See the section called Fuzziness
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchBase.MinimumShouldMatch">
             <summary>
             minimum_should_match
             The minimum_should_match parameter possible values:
             
             Integer : Indicates a fixed value regardless of the number of optional clauses.
             Negative integer : Indicates that the total number of optional clauses, minus this number should be mandatory.
             Percentage 75% : Indicates that this percent of the total number of optional clauses are necessary. The number computed from the percentage is rounded down and used as the minimum.
             Negative percentage -25% Indicates that this percent of the total number of optional clauses can be missing.
              The number computed from the percentage is rounded down, before being subtracted from the total to determine the minimum.
             Combination : A positive integer, followed by the less-than symbol, followed by any of the previously mentioned specifiers is a conditional specification.
              It indicates that if the number of optional clauses is equal to (or less than) the integer, they are all required, but if it’s greater than the integer,
              the specification applies. In this example: if there are 1 to 3 clauses they are all required, but for 4 or more clauses only 90% are required.
             Multiple combinations :  Multiple conditional specifications can be separated by spaces, each one only being valid for numbers greater than the one before it.
              In this example: if there are 1 or 2 clauses both are required, if there are 3-9 clauses all but 25% are required, and if there are more than 9 clauses,
              all but three are required.
            
             NOTE:
             When dealing with percentages, negative values can be used to get different behavior in edge cases. 75% and -25% mean the same thing when dealing with 4 clauses, 
             but when dealing with 5 clauses 75% means 3 are required, but -25% means 4 are required.
            
             If the calculations based on the specification determine that no optional clauses are needed, 
             the usual rules about BooleanQueries still apply at search time (a BooleanQuery containing no required clauses must still match at least one optional clause)
            
             No matter what number the calculation arrives at, a value greater than the number of optional clauses, or a value less than 1 will never be used. 
             (ie: no matter how low or how high the result of the calculation result is, the minimum number of required matches will never be lower than 1 or greater than the number of clauses.
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.MatchPhaseQuery">
            <summary>
            The match_phrase query analyzes the text and creates a phrase query out of the analyzed text.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchPhaseQuery.Slop">
            <summary>
            slop
            
            The slop parameter tells the match_phrase query how far apart terms are allowed to be while still considering the document a match. 
            By how far apart we mean how many times do you need to move a term in order to make the query and document match?
            		
            Phrase and proximity queries are more expensive than simple match queries. Whereas a match query just has to look up terms in the inverted index, 
            a match_phrase query has to calculate and compare the positions of multiple possibly repeated terms.
            The Lucene nightly benchmarks show that a simple term query is about 10 times as fast as a phrase query, 
            and about 20 times as fast as a proximity query (a phrase query with slop). And of course, this cost is paid at search time instead of at index time.
            
            Usually the extra cost of phrase queries is not as scary as these numbers suggest. Really, the difference in performance is a testimony to just how fast a simple term query is. 
            Phrase queries on typical full-text data usually complete within a few milliseconds, and are perfectly usable in practice, even on a busy cluster.
            In certain pathological cases, phrase queries can be costly, but this is unusual. An example of a pathological case is DNA sequencing, 
            where there are many many identical terms repeated in many positions. Using higher slop values in this case results in a huge growth in the number of position calculations.
            
            http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/slop.html
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.MatchPhasePrefixQuery">
            <summary>
            The match_phrase_prefix is the same as match_phrase, except that it allows for prefix matches on the last term in the text
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchPhasePrefixQuery.Slop">
            <summary>
            slop
            
            The slop parameter tells the match_phrase query how far apart terms are allowed to be while still considering the document a match. 
            By how far apart we mean how many times do you need to move a term in order to make the query and document match?
            
            Phrase and proximity queries are more expensive than simple match queries. Whereas a match query just has to look up terms in the inverted index, 
            a match_phrase query has to calculate and compare the positions of multiple possibly repeated terms.
            The Lucene nightly benchmarks show that a simple term query is about 10 times as fast as a phrase query, 
            and about 20 times as fast as a proximity query (a phrase query with slop). And of course, this cost is paid at search time instead of at index time.
            
            Usually the extra cost of phrase queries is not as scary as these numbers suggest. Really, the difference in performance is a testimony to just how fast a simple term query is. 
            Phrase queries on typical full-text data usually complete within a few milliseconds, and are perfectly usable in practice, even on a busy cluster.
            In certain pathological cases, phrase queries can be costly, but this is unusual. An example of a pathological case is DNA sequencing, 
            where there are many many identical terms repeated in many positions. Using higher slop values in this case results in a huge growth in the number of position calculations.
            
            http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/slop.html
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MatchPhasePrefixQuery.MaxExpansions">
            <summary>
            a max_expansions parameter that can control to how many prefixes the last term will be expanded. 
            It is highly recommended to set it to an acceptable value to control the execution time of the query.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatch.MultiMatchType">
            <summary>
            type 
            see MultiMatchType for possible values
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatch.TieBreaker">
            <summary>
            tie_breaker
            By default, each per-term blended query will use the best score returned by any field in a group, then these scores are added together to give the final score. 
            The tie_breaker parameter can change the default behaviour of the per-term blended queries. It accepts:
            
            0.0 Take the single best score out of (eg) first_name:will and last_name:will (default)
            1.0 Add together the scores for (eg) first_name:will and last_name:will
            0.0 between 1.0 Take the single best score plus tie_breaker multiplied by each of the scores from other matching fields. 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatchType.best_fields">
            <summary>
            (default) Finds documents which match any field, but uses the _score from the best field. See best_fields.
            
            The best_fields type is most useful when you are searching for multiple words best found in the same field. For instance “brown fox” in a single field is more 
            meaningful than “brown” in one field and “fox” in the other.
            The best_fields type generates a match query for each field and wraps them in a dis_max query, to find the single best matching field. 
            
            Normally the best_fields type uses the score of the single best matching field, but if tie_breaker is specified, then it calculates the score as follows:
            the score from the best matching field plus tie_breaker * _score for all other matching fields 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatchType.most_fields">
            <summary>
            Finds documents which match any field and combines the _score from each field. See most_fields.
            
            The most_fields type is most useful when querying multiple fields that contain the same text analyzed in different ways. For instance, 
            the main field may contain synonyms, stemming and terms without diacritics. A second field may contain the original terms, and a third field might contain shingles. 
            By combining scores from all three fields we can match as many documents as possible with the main field, 
            but use the second and third fields to push the most similar results to the top of the list.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatchType.cross_fields">
            <summary>
            Treats fields with the same analyzer as though they were one big field. Looks for each word in any field. See cross_fields.
            
            The cross_fields type is particularly useful with structured documents where multiple fields should match. 
            For instance, when querying the first_name and last_name fields for “Will Smith”, the best match is likely to have “Will” in one field and “Smith” in the other.
            
            One way of dealing with these types of queries is simply to index the first_name and last_name fields into a single full_name field. Of course, this can only be done at index time.
            
            The cross_field type tries to solve these problems at query time by taking a term-centric approach. It first analyzes the query string into individual terms, 
            then looks for each term in any of the fields, as though they were one big field.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatchType.phrase">
            <summary>
            Runs a match_phrase query on each field and combines the _score from each field. See phrase and phrase_prefix.
            
            The phrase and phrase_prefix types behave just like best_fields, but they use a match_phrase or match_phrase_prefix query instead of a match query.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Queries.MultiMatchType.phrase_prefix">
            <summary>
            Runs a match_phrase_prefix query on each field and combines the _score from each field. See phrase and phrase_prefix. 
            
            The phrase and phrase_prefix types behave just like best_fields, but they use a match_phrase or match_phrase_prefix query instead of a match query.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery">
            <summary>
            Matches documents with fields that have terms within a certain range. The type of the Lucene query depends on the field type, 
            for string fields, the TermRangeQuery, while for number/date fields, the query is a NumericRangeQuery. The 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.GreaterThanOrEqualTo">
            <summary>
            gte
            Greater-than or equal to
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.GreaterThan">
            <summary>
            gt
            Greater-than
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.LessThanOrEqualTo">
            <summary>
            lte
            Less-than or equal to
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.LessThan">
            <summary>
            lt
            Less-than
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.IncludeLower">
            <summary>
            include_lower
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.IncludeUpper">
            <summary>
            include_upper
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.RangeQuery.TimeZone">
            <summary>
            time_zone
            When applied on date fields the range filter accepts also a time_zone parameter. 
            The time_zone parameter will be applied to your input lower and upper bounds and will move them to UTC time based date
            
            if you give a date with a timezone explicitly defined and use the time_zone parameter, time_zone will be ignored. For example,
            setting gte to 2012-01-01T00:00:00+01:00 with "time_zone":"+10:00" will still use +01:00 time zone.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Queries.TermQuery">
            <summary>
            Matches documents that have fields that contain a term (not analyzed). The term query maps to Lucene TermQuery.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Queries.TermsQuery.MinimumShouldMatch">
             <summary>
             minimum_should_match
             The minimum_should_match parameter possible values:
             
             Integer : Indicates a fixed value regardless of the number of optional clauses.
             Negative integer : Indicates that the total number of optional clauses, minus this number should be mandatory.
             Percentage 75% : Indicates that this percent of the total number of optional clauses are necessary. The number computed from the percentage is rounded down and used as the minimum.
             Negative percentage -25% Indicates that this percent of the total number of optional clauses can be missing.
              The number computed from the percentage is rounded down, before being subtracted from the total to determine the minimum.
             Combination : A positive integer, followed by the less-than symbol, followed by any of the previously mentioned specifiers is a conditional specification.
              It indicates that if the number of optional clauses is equal to (or less than) the integer, they are all required, but if it’s greater than the integer,
              the specification applies. In this example: if there are 1 to 3 clauses they are all required, but for 4 or more clauses only 90% are required.
             Multiple combinations :  Multiple conditional specifications can be separated by spaces, each one only being valid for numbers greater than the one before it.
              In this example: if there are 1 or 2 clauses both are required, if there are 3-9 clauses all but 25% are required, and if there are more than 9 clauses,
              all but three are required.
            
             NOTE:
             When dealing with percentages, negative values can be used to get different behavior in edge cases. 75% and -25% mean the same thing when dealing with 4 clauses, 
             but when dealing with 5 clauses 75% means 3 are required, but -25% means 4 are required.
            
             If the calculations based on the specification determine that no optional clauses are needed, 
             the usual rules about BooleanQueries still apply at search time (a BooleanQuery containing no required clauses must still match at least one optional clause)
            
             No matter what number the calculation arrives at, a value greater than the number of optional clauses, or a value less than 1 will never be used. 
             (ie: no matter how low or how high the result of the calculation result is, the minimum number of required matches will never be lower than 1 or greater than the number of clauses.
             </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Query">
            <summary>
            As a general rule, queries should be used instead of filters:
            
            - for full text search
            - where the result depends on a relevance score 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Search">
            <summary>
            The search request can be executed with a search DSL, which includes the Query DSL, within its body.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Search.Timeout">
            <summary>
            timeout
            A search timeout, bounding the search request to be executed within the specified time value and bail with the hits accumulated up to that point when expired. 
            Defaults to no timeout. See the section called “Time unitsedit”. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Search.From">
            <summary>
            from
            The starting from index of the hits to return. Defaults to 0. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Search.Size">
            <summary>
            size
            The number of hits to return. Defaults to 10. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Search.TerminateAfter">
            <summary>
            terminate_after
            [1.4.0.Beta1] Added in 1.4.0.Beta1. The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early. 
            If set, the response will have a boolean field terminated_early to indicate whether the query execution has actually terminated_early. Defaults to no terminate_after. 
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Search.Aggs">
            <summary>
            aggregations request
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Sorting.SortScript">
             <summary>
             Allow to sort based on custom scripts
             
             "sort" : {
            	"_script" : {
            		"script" : "doc['field_name'].value * factor",
            		"type" : "number",
            		"params" : {
            			"factor" : 1.1
            		},
            		"order" : "asc"
            	}
            }
             </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Sorting.SortStandard.Mode">
            <summary>
            mode
            Elasticsearch supports sorting by array or multi-valued fields. 
            The mode option controls what array value is picked for sorting the document it belongs to. The mode option can have the following values:
            SortMode enum: min, max, sum, avg
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Sorting.SortStandard.Missing">
            <summary>
            The missing parameter specifies how docs which are missing the field should be treated: 
            The missing value can be set to _last, _first, or a custom value (that will be used for missing docs as the sort value).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Sorting.SortStandard.NestedFilter">
            <summary>
            "nested_filter"
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Sorting.SortStandard.UnmappedType">
            <summary>
            unmapped_type
            By default, the search request will fail if there is no mapping associated with a field. The unmapped_type option allows to ignore fields that have no mapping and not sort by them. 
            The value of this parameter is used to determine what sort values to emit.
            
            If any of the indices that are queried doesn’t have a mapping for price then Elasticsearch will handle it as if there was a mapping of type long, 
            with all documents in this index having no value for this field.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortMode.min">
            <summary>
            Pick the lowest value.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortMode.max">
            <summary>
            Pick the highest value.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortMode.sum">
            <summary>
            Use the sum of all values as sort value. Only applicable for number based array fields.
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.Model.SearchModel.Sorting.SortMode.avg">
            <summary>
            Use the average of all values as sort value. Only applicable for number based array fields. 
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.SearchModel.Sorting.SortHolder">
            <summary>
            Allows to add one or more sort on specific fields. Each sort can be reversed as well. 
            The sort is defined on a per field level, with special field name for _score to sort by score.
            
            When sorting, the relevant sorted field values are loaded into memory. This means that per shard, there should be enough memory to contain them. 
            For string based types, the field sorted on should not be analyzed / tokenized. For numeric types, if possible, 
            it is recommended to explicitly set the type to six_hun types (like short, integer and float).
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.Model.SearchModel.Sorting.SortHolder.TrackScores">
            <summary>
            track_scores
            When sorting on a field, scores are not computed. By setting track_scores to true, scores will still be computed and tracked.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.Shards">
            <summary>
            "_shards":{"total":5,"successful":5,"failed":0}
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.Model.Units.DistanceUnit">
            <summary>
            Wherever distances need to be specified, such as the distance parameter in the Geo Distance Filter), 
            the default unit if none is specified is the meter. Distances can be specified in other units, such as "1km" or "2mi" (2 miles).
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.ElasticsearchCrudReindex`2.ScanAndScrollConfiguration">
            <summary>
            Scan ans scroll settings for the reindex. You should keep this small, otherwise the response request will be too larger.
            Default is 5 seconds with a size of 500 documents pro shard.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchCrudReindex`2.#ctor(ElasticsearchCRUD.Model.IndexTypeDescription,ElasticsearchCRUD.Model.IndexTypeDescription,System.String)">
            <summary>
            Reindex constructor. The class reuires a index and a type for the old index and also the new index. The old index can then be converteds or reindexed to the new index.
            </summary>
            <param name="oldIndexTypeDescription">index and index type parameters for the old index</param>
            <param name="newIndexTypeDescription">index and index type parameters for the new index</param>
            <param name="connectionString">Elasticsearch connection string</param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchCrudReindex`2.SwitchAliasfromOldToNewIndex(System.String)">
            <summary>
            Resets the alias from the old index to the new index. Assumes that a alias is used for the old indeex. This way, reindex can be done live.
            </summary>
            <param name="alias">alias string used for the index.</param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchCrudReindex`2.Reindex(System.String,System.Func{`0,System.Object},System.Func{`0,`1},System.Func{`0,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition})">
            <summary>
            This method is used to reindex one index to a new index using a query, and two Functions.
            </summary>
            <param name="jsonContent">Json content for the search query</param>
            <param name="getKeyMethod">Func is require to define the _id required for the new index</param>
            <param name="convertMethod">Func used to map the old index to the new old, whatever your required mapping/conversion logic is</param>
            <param name="getRoutingDefinition">Function to get the RoutingDefinition of the document</param>
        </member>
        <member name="P:ElasticsearchCRUD.ElasticsearchCrudReindex`2.TraceProvider">
            <summary>
            TraceProvider if logging or tracing is used
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ElasticsearchSerializerConfiguration">
            <summary>
            Configuration class used for the context settings.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ElasticsearchSerializerConfiguration.ElasticsearchMappingResolver">
            <summary>
            Mapping resolver used to get set each mapping configuration for a type. A type can only have one mapping pro context.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ElasticsearchSerializerConfiguration.SaveChildObjectsAsWellAsParent">
            <summary>
            Saves all child objects as well as the parent if set. 
            The child objects will be saved as nested or as separate documents depending on ProcessChildDocumentsAsSeparateChildIndex
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ElasticsearchSerializerConfiguration.ProcessChildDocumentsAsSeparateChildIndex">
            <summary>
            Context will save child objects as separate types in the same index if set. Otherwise child itemas are saved as nested objects.
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ElasticsearchSerializerConfiguration.UserDefinedRouting">
            <summary>
            This defines idf you want to define your own routing. You should only do this if you know what you are doing
            or you have grandchild documents in a parent child grandchild relationship. This makes certain that the grandchildren are
            defined on the same shard. It also cuses that gets, etc required the routing value of the parent route document...
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ElasticsearchMapping">
            <summary>
            Default mapping for your Entity. You can implement this clas to implement your specific mapping if required
            Everything is lowercase and the index is pluralized
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchMapping.MapEntityValues(ElasticsearchCRUD.Model.EntityContextInfo,ElasticsearchCRUD.ElasticsearchCrudJsonWriter,System.Boolean,System.Boolean)">
            <summary>
            Ovveride this if your default mapping needs to be changed.
            default type is lowercase for properties, indes pluralized and type to lower
            </summary>
            <param name="entityInfo">Information about the entity</param>
            <param name="elasticsearchCrudJsonWriter">Serializer with added tracing</param>
            <param name="beginMappingTree">begin new mapping tree</param>
            <param name="createPropertyMappings">This tells the serializer to create a Json property mapping from the entity and not the document itself</param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchMapping.GetDocumentType(System.Type)">
            <summary>
            Override this if you require a special type definitoin for your document type.
            </summary>
            <param name="type"></param>
            <returns>The type used in Elasticsearch for this type</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchMapping.GetIndexForType(System.Type)">
            <summary>
            Overide this if you need to define the index for your document. 
            Required if your using a child document type.
            Default: pluralize the default type
            </summary>
            <param name="type">Type of class used</param>
            <returns>The index used in Elasticsearch for this type</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchMapping.GetElasticsearchType(System.Type)">
            <summary>
            bool System.Boolean
            byte System.Byte
            sbyte System.SByte 
            char System.Char
            decimal System.Decimal => string
            double System.Double
            float System.Single
            int System.Int32
            uint System.UInt32
            long System.Int64
            ulong System.UInt64
            short System.Int16
            ushort System.UInt16
            string System.String 
            </summary>
            <param name="propertyType"></param>
            <returns>
            string,  boolean, and null.
            float, double, byte, short, integer, and long
            date
            binary
            </returns>
        </member>
        <member name="T:ElasticsearchCRUD.Utils.GlobalElasticsearchMapping">
            <summary>
            This mapping can be used if you require a search accross all indices and all types.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ElasticsearchContext">
            <summary>
            Context for crud operations. 
            </summary>
        </member>
        <member name="F:ElasticsearchCRUD.ElasticsearchContext._traceProvider">
            <summary>
            TraceProvider for all logs, trace etc. This can be replaced with any TraceProvider implementation.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.#ctor(System.String,ElasticsearchCRUD.ElasticsearchSerializerConfiguration)">
            <summary>
            ctor
            </summary>
            <param name="connectionString">Connection string which is used as ther base URL for the HttpClient</param>
            <param name="elasticsearchSerializerConfiguration">Configuration class for the context. The default settings can be oset here. This 
            class contains an IElasticsearchMappingResolver</param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.#ctor(System.String,ElasticsearchCRUD.IElasticsearchMappingResolver)">
            <summary>
            ctor
            </summary>
            <param name="connectionString">Connection string which is used as ther base URL for the HttpClient</param>
            <param name="elasticsearchMappingResolver">Resolver used for getting the index and type of a document type. The default 
            ElasticsearchSerializerConfiguration is used in this ctor.</param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AddUpdateDocument(System.Object,System.Object,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition)">
            <summary>
            Adds a document to the pending changes list. Nor HTTP request is sent with this method. If the save changes is not called, the
            document is not added or updated in the search engine
            </summary>
            <param name="document">Document to be added or updated</param>
            <param name="id">document id</param>
            <param name="routingDefinition">parent id of the document. This is only used if the ElasticsearchSerializerConfiguration.ProcessChildDocumentsAsSeparateChildIndex
            property is set to true. The document is then saved with the parent routing. It will also be saved even if the parent does not exist.</param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteDocument``1(System.Object,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition)">
            <summary>
            Adds a document to the pending changes list to be deletedd. Nor HTTP request is sent with this method. If the save changes is not called, the
            document is not added or updated in the search engine
            </summary>
            <typeparam name="T">This type is used to get the index and type of the document</typeparam>
            <param name="id">id of the document which will be deleted.</param>
            <param name="routingDefinition"></param>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SaveChangesAndInitMappings">
            <summary>
            Saves all the changes in the pending list of changes, add, update and delete. It also creates mappings and indexes
            if the child documents are saved as separate index types. ElasticsearchSerializerConfiguration.ProcessChildDocumentsAsSeparateChildIndex= true
            </summary>
            <returns>Returns HTTP response information</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SaveChanges">
            <summary>
            Saves all the changes in the pending list of changes, add, update and delete. No mappings are created here for child document types.
            </summary>
            <returns>Returns HTTP response information</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SaveChangesAsync">
            <summary>
            async Saves all the changes in the pending list of changes, add, update and delete. No mappings are created here for child document types.
            </summary>
            <returns>Returns HTTP response information</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexOptimize(System.String,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters)">
            <summary>
            The optimize API allows to optimize one or more indices through an API. 
            The optimize process basically optimizes the index for faster search operations (and relates to the number of segments a Lucene index holds within each shard). 
            The optimize operation allows to reduce the number of segments by merging them.
            </summary>
            <param name="index">index to optimize</param>
            <param name="optimizeParameters">all the possible parameters</param>
            <returns>number of successfully optimized</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexOptimizeAsync(System.String,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.OptimizeParameters)">
            <summary>
            Async The optimize API allows to optimize one or more indices through an API. 
            The optimize process basically optimizes the index for faster search operations (and relates to the number of segments a Lucene index holds within each shard). 
            The optimize operation allows to reduce the number of segments by merging them.
            </summary>
            <param name="index">index to optimize</param>
            <param name="optimizeParameters">all the possible parameters</param>
            <returns>number of successfully optimized</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexClose(System.String)">
            <summary>
            The open and close index APIs allow to close an index, and later on opening it. 
            A closed index has almost no overhead on the cluster (except for maintaining its metadata), and is blocked for read/write operations.
             A closed index can be opened which will then go through the normal recovery process.
            </summary>
            <param name="index">index to be closed</param>
            <returns>true ids successfuly</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCloseAsync(System.String)">
            <summary>
            Async The open and close index APIs allow to close an index, and later on opening it. 
            A closed index has almost no overhead on the cluster (except for maintaining its metadata), and is blocked for read/write operations.
             A closed index can be opened which will then go through the normal recovery process.
            </summary>
            <param name="index">index to be closed</param>
            <returns>true ids successfuly</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexOpen(System.String)">
            <summary>
            The open and close index APIs allow to close an index, and later on opening it. 
            A closed index has almost no overhead on the cluster (except for maintaining its metadata), and is blocked for read/write operations.
             A closed index can be opened which will then go through the normal recovery process.
            </summary>
            <param name="index">index to be opened</param>
            <returns>true ids successfuly</returns>
            
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexOpenAsync(System.String)">
            <summary>
            Async The open and close index APIs allow to close an index, and later on opening it. 
            A closed index has almost no overhead on the cluster (except for maintaining its metadata), and is blocked for read/write operations.
             A closed index can be opened which will then go through the normal recovery process.
            </summary>
            <param name="index">index to be opened</param>
            <returns>true ids successfuly</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexUpdateSettings(ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings,System.String)">
            <summary>
            Change specific index level settings in real time
            Can change a single index or global changes
            </summary>
            <param name="indexUpdateSettings">index settings, see properties doc for details</param>
            <param name="index">index to be updated, if null, updatesa all indices</param>
            <returns>string with details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexUpdateSettingsAsync(ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexUpdateSettings,System.String)">
            <summary>
            Async Change specific index level settings in real time
            Can change a single index or global changes
            </summary>
            <param name="indexUpdateSettings">index settings, see properties doc for details</param>
            <param name="index">index to be updated, if null, updatesa all indices</param>
            <returns>string with details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCreate(System.String,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexSettings,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexAliases)">
            <summary>
            Creates a new index
            </summary>
            <param name="index">index name to lower string!</param>
            <param name="indexSettings">settings for the new index</param>
            <param name="indexAliases">Define aliases for the index at creation time</param>
            <returns>details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCreateAsync(System.String,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexSettings,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexAliases)">
            <summary>
            Async Creates a new index
            </summary>
            <param name="index">index name to lower string!</param>
            <param name="indexSettings">settings for the new index</param>
            <param name="indexAliases">Define aliases for the index at creation time</param>
            <returns>details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCreate``1(ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexDefinition)">
            <summary>
            Creates a new index from a Type and also all the property mappings and index definitions
            Note: Child objects cannot be an interface if the mapping should be created first.
            </summary>
            <param name="indexDefinition">settings for the new index</param>
            <returns>details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCreateAsync``1(ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.SettingsModel.IndexDefinition)">
            <summary>
            Async Creates a new index from a Type and also all the property mappings and index definitions
            </summary>
            <param name="indexDefinition">settings for the new index</param>
            <returns>details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCreateTypeMapping``1(ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingDefinition)">
            <summary>
            Creates propety mappings for an existing index
            </summary>
            <typeparam name="T">Type for the mapping</typeparam>
            <param name="mappingDefinition">Routing index definitions</param>
            <returns>details of the request</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexCreateTypeMappingAsync``1(ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.MappingModel.MappingDefinition)">
            <summary>
            Async Creates propety mappings for an existing index
            </summary>
            <typeparam name="T">Type for the mapping</typeparam>
            <param name="mappingDefinition">Routing index definitions</param>
            <returns>details of the request</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.GetDocument``1(System.Object,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition)">
            <summary>
            Gets a document by id. Elasticsearch GET API
            </summary>
            <typeparam name="T">type used for the document index and type definition</typeparam>
            <param name="documentId">document id</param>
            <param name="routingDefinition">Parent Id of the document if document is a child document Id the Id is incorrect, you may still recieve the child document (parentId might be
            saved to the same shard.) If the child is a child document and no parent id is set, no docuemnt will be found.</param>
            <returns>Document type T</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchById``1(System.Object,ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters)">
            <summary>
            Uses Elasticsearch search API to get the document per id
            </summary>
            <typeparam name="T">type T used to get index anf the type of the document.</typeparam>
            <param name="documentId"></param>
            <param name="searchUrlParameters">add routing or pretty parameters if required</param>
            <returns>Returns the document of type T</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchByIdAsync``1(System.Object,ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters)">
            <summary>
            async Uses Elasticsearch search API to get the document per id
            </summary>
            <typeparam name="T">type T used to get index anf the type of the document.</typeparam>
            <param name="documentId"></param>
            <param name="searchUrlParameters">add routing or pretty parameters if required</param>
            <returns>Returns the document of type T in a Task with result details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Search``1(System.String,ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters)">
            <summary>
            Search API method to search for anything. Any json string which matches the Elasticsearch Search API can be used. Only single index and type search
            </summary>
            <typeparam name="T">Type T used for the index and tpye used in the search</typeparam>
            <param name="searchJsonParameters">JSON string which matches the Elasticsearch Search API</param>
            <param name="searchUrlParameters">add routing or pretty parameters if required</param>
            <returns>A collection of documents of type T</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Search``1(ElasticsearchCRUD.Model.SearchModel.Search,ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters)">
            <summary>
            Search API method to search for anything. Any json string which matches the Elasticsearch Search API can be used. Only single index and type search
            </summary>
            <typeparam name="T">Type T used for the index and tpye used in the search</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <param name="searchUrlParameters">add routing or pretty parameters if required</param>
            <returns>A collection of documents of type T</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchAsync``1(System.String,ElasticsearchCRUD.ContextSearch.SearchModel.SearchUrlParameters)">
            <summary>
            async Search API method to search for anything. Any json string which matches the Elasticsearch Search API can be used. Only single index and type search
            </summary>
            <typeparam name="T">Type T used for the index and tpye used in the search</typeparam>
            <param name="searchJsonParameters">JSON string which matches the Elasticsearch Search API</param>
            <param name="searchUrlParameters">add routing or pretty parameters if required</param>
            <returns>A collection of documents of type T in a Task</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchScanAndScroll``1(System.String,ElasticsearchCRUD.ContextSearch.ScanAndScrollConfiguration)">
            <summary>
            Search API method to search for anything. Any json string which matches the Elasticsearch Search API can be used. Only single index and type search
            </summary>
            <typeparam name="T">Type T used for the index and tpye used in the search</typeparam>
            <param name="scrollId">If this search is part of a scan and scroll, you can add the scrollId to open the context</param>
            <param name="scanAndScrollConfiguration">Required scroll configuration</param>
            <returns>A collection of documents of type T</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchScanAndScrollAsync``1(System.String,ElasticsearchCRUD.ContextSearch.ScanAndScrollConfiguration)">
            <summary>
            async Search API method to search for anything. Any json string which matches the Elasticsearch Search API can be used. Only single index and type search
            </summary>
            <typeparam name="T">Type T used for the index and tpye used in the search</typeparam>
            <param name="scrollId">If this search is part of a scan and scroll, you can add the scrollId to open the context</param>
            <param name="scanAndScrollConfiguration">Required scroll configuration</param>
            <returns>A collection of documents of type T in a Task</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchExists``1(System.String,System.String)">
            <summary>
            executes a post request to checks if at least one document exists for the search query.
            </summary>
            <typeparam name="T">Type used to define the type and index in elsticsearch</typeparam>
            <param name="searchJsonParameters">json query for elasticsearch</param>
            <param name="routing">routing used for the search</param>
            <returns>true if one document exists for the search query</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchExists``1(ElasticsearchCRUD.Model.SearchModel.Search,System.String)">
            <summary>
            executes a post request to checks if at least one document exists for the search query.
            </summary>
            <typeparam name="T">Type used to define the type and index in elsticsearch</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <param name="routing">routing used for the search</param>
            <returns>true if one document exists for the search query</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchExistsAsync``1(System.String,System.String)">
            <summary>
            async executes a post request to checks if at least one document exists for the search query.
            </summary>
            <typeparam name="T">Type used to define the type and index in elsticsearch</typeparam>
            <param name="searchJsonParameters">json query for elasticsearch</param>
            <param name="routing">routing used for the search</param>
            <returns>true if one document exists for the search query</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchExistsAsync``1(ElasticsearchCRUD.Model.SearchModel.Search,System.String)">
            <summary>
            async executes a post request to checks if at least one document exists for the search query.
            </summary>
            <typeparam name="T">Type used to define the type and index in elsticsearch</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <param name="routing">routing used for the search</param>
            <returns>true if one document exists for the search query</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchCreateScanAndScroll``1(System.String,ElasticsearchCRUD.ContextSearch.ScanAndScrollConfiguration)">
            <summary>
            Creates a new scan and scroll search. Takes the query json content and returns a _scroll_id in the payload for the following searches.
            If your doing a live reindexing, you should use a timestamp in the json content query.
            </summary>
            <typeparam name="T">index and type formt search scan and scroll</typeparam>
            <param name="jsonContent">query which will be saved.</param>
            <param name="scanAndScrollConfiguration">The scan and scroll configuration, for example scroll in time units</param>
            <returns>Returns the _scroll_id in the Payload property and the total number of hits.</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchCreateScanAndScroll``1(ElasticsearchCRUD.Model.SearchModel.Search,ElasticsearchCRUD.ContextSearch.ScanAndScrollConfiguration)">
            <summary>
            Creates a new scan and scroll search. Takes the query json content and returns a _scroll_id in the payload for the following searches.
            If your doing a live reindexing, you should use a timestamp in the json content query.
            </summary>
            <typeparam name="T">index and type formt search scan and scroll</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <param name="scanAndScrollConfiguration">The scan and scroll configuration, for example scroll in time units</param>
            <returns>Returns the _scroll_id in the Payload property and the total number of hits.</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchCreateScanAndScrollAsync``1(System.String,ElasticsearchCRUD.ContextSearch.ScanAndScrollConfiguration)">
            <summary>
            Async Creates a new scan and scroll search. Takes the query json content and returns a _scroll_id in the payload for the following searches.
            If your doing a live reindexing, you should use a timestamp in the json content query.
            </summary>
            <typeparam name="T">index and type formt search scan and scroll</typeparam>
            <param name="jsonContent">query which will be saved.</param>
            <param name="scanAndScrollConfiguration">The scan and scroll configuration, for example scroll in time units</param>
            <returns>Returns the _scroll_id in the Payload property and the total number of hits.</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.SearchCreateScanAndScrollAsync``1(ElasticsearchCRUD.Model.SearchModel.Search,ElasticsearchCRUD.ContextSearch.ScanAndScrollConfiguration)">
            <summary>
            Async Creates a new scan and scroll search. Takes the query json content and returns a _scroll_id in the payload for the following searches.
            If your doing a live reindexing, you should use a timestamp in the json content query.
            </summary>
            <typeparam name="T">index and type formt search scan and scroll</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <param name="scanAndScrollConfiguration">The scan and scroll configuration, for example scroll in time units</param>
            <returns>Returns the _scroll_id in the Payload property and the total number of hits.</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Count``1(System.String)">
            <summary>
            ElasticsearchContextCount to amount of hits for a index, type and query.
            </summary>
            <typeparam name="T">Type to find</typeparam>
            <param name="jsonContent">json query data, returns all in emtpy</param>
            <returns>Result amount of document found</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Count``1(ElasticsearchCRUD.Model.SearchModel.Search)">
            <summary>
            ElasticsearchContextCount to amount of hits for a index, type and query.
            </summary>
            <typeparam name="T">Type to find</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <returns>Result amount of document found</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.CountAsync``1(System.String)">
            <summary>
            ElasticsearchContextCount to amount of hits for a index, type and query.
            </summary>
            <typeparam name="T">Type to find</typeparam>
            <param name="jsonContent">json query data, returns all in emtpy</param>
            <returns>Result amount of document found in a result details task</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.CountAsync``1(ElasticsearchCRUD.Model.SearchModel.Search)">
            <summary>
            ElasticsearchContextCount to amount of hits for a index, type and query.
            </summary>
            <typeparam name="T">Type to find</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <returns>Result amount of document found in a result details task</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteByQueryAsync``1(System.String)">
            <summary>
            Async Deletes all documents found using the query in the body.
            </summary>
            <typeparam name="T">Type used to define the index and the type in Elasticsearch</typeparam>
            <param name="jsonContent">json string using directly in Elasticsearch API. </param>
            <returns>Returns true if ok</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteByQuery``1(System.String)">
            <summary>
            Deletes all documents found using the query in the body.
            </summary>
            <typeparam name="T">Type used to define the index and the type in Elasticsearch</typeparam>
            <param name="jsonContent">json string using directly in Elasticsearch API. </param>
            <returns>Returns true if ok</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteByQuery``1(ElasticsearchCRUD.Model.SearchModel.Search)">
            <summary>
            Deletes all documents found using the query in the body.
            </summary>
            <typeparam name="T">Type used to define the index and the type in Elasticsearch</typeparam>
            <param name="search">search body for Elasticsearch Search API</param>
            <returns>Returns true if ok</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.GetDocumentAsync``1(System.Object,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition)">
            <summary>
            Gets a document by id. Elasticsearch GET API
            </summary>
            <typeparam name="T">type used for the document index and type definition</typeparam>
            <param name="documentId">document id</param>
            <param name="routingDefinition">Parent Id of the document if document is a child document Id the Id is incorrect, you may still recieve the child document (parentId might be
            saved to the same shard.) If the child is a child document and no parent id is set, no docuemnt will be found.</param>
            <returns>Document type T in a Task with result details</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DocumentExists``1(System.Object,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition)">
            <summary>
            Checks if a document exists with a head request
            </summary>
            <typeparam name="T">Type of document to find</typeparam>
            <param name="documentId">Id of the document</param>
            <param name="routingDefinition">parent Id, required if hte docuemtnis a child document and routing is required.
            NOTE: if the parent Id is incorrect but save on the same shard as the correct parentId, the document will be found!</param>
            <returns>true or false</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DocumentExistsAsync``1(System.Object,ElasticsearchCRUD.ContextAddDeleteUpdate.IndexModel.RoutingDefinition)">
            <summary>
            Async Checks if a document exists with a head request
            </summary>
            <typeparam name="T">Type of document to find</typeparam>
            <param name="documentId">Id of the document</param>
            <param name="routingDefinition">parent Id, required if hte docuemtnis a child document and routing is required.
            NOTE: if the parent Id is incorrect but save on the same shard as the correct parentId, the document will be found!</param>
            <returns>true or false</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Exists(System.Uri)">
            <summary>
            Send a HEAD request to Eleasticseach to find out if the item defined in the URL exists
            </summary>
            <param name="uri">Full URI of Elasticseach plus item</param>
            <returns>true if it exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.ExistsAsync(System.Uri)">
            <summary>
            Async Send a HEAD request to Eleasticseach to find out if the item defined in the URL exists
            </summary>
            <param name="uri">Full URI of Elasticseach plus item</param>
            <returns>true if it exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexExists``1">
            <summary>
            async Checks if a index exists for the type T
            </summary>
            <typeparam name="T">Type used for the index exists HEAD request. Gets the index using the mapping</typeparam>
            <returns>true if it exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexExistsAsync``1">
            <summary>
            async Checks if a index exists for the type T
            </summary>
            <typeparam name="T">Type used for the index exists HEAD request. Gets the index using the mapping</typeparam>
            <returns>true if it exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexTypeExists``1">
            <summary>
            Checks if a type exists for an index for the type T
            </summary>
            <typeparam name="T">Type used for the index + plus exists HEAD request. Gets the index using the mapping</typeparam>
            <returns>true if it exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexTypeExistsAsync``1">
            <summary>
            Checks if a type exists for an index for the type T
            </summary>
            <typeparam name="T">Type used for the index + plus exists HEAD request. Gets the index using the mapping</typeparam>
            <returns>true if it exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasExistsForIndex``1(System.String)">
            <summary>
            Checks if an alias exists for an index for the type T
            </summary>
            <typeparam name="T">Type used for the index + plus exists HEAD request. Gets the index using the mapping</typeparam>
            <returns>true if the alias exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasExistsForIndexAsync``1(System.String)">
            <summary>
            async Checks if an alias exists for an index for the type T
            </summary>
            <typeparam name="T">Type used for the index + plus exists HEAD request. Gets the index using the mapping</typeparam>
            <returns>true if the alias exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasExists(System.String)">
            <summary>
            Checks if an alias exists
            </summary>
            <returns>true if the alias exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasExistsAsync(System.String)">
            <summary>
            async Checks if an alias exists
            </summary>
            <returns>true if the alias exists false for 404</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexClearCache``1">
            <summary>
            Clears the cache for the index. The index is defined using the Type
            </summary>
            <typeparam name="T">Type used to get the index name</typeparam>
            <returns>returns true if cache has been cleared</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexClearCache(System.String)">
            <summary>
            Clears the cache for the index. The index is defined using the Type
            </summary>
            <returns>returns true if cache has been cleared</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.IndexClearCacheAsync``1">
            <summary>
            Async Clears the cache for the index. The index is defined using the Type
            </summary>
            <typeparam name="T">Type used to get the index name</typeparam>
            <returns>returns true if cache has been cleared</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasCreateForIndex(System.String,System.String)">
            <summary>
            Creates a new alias for the index parameter. 
            </summary>
            <param name="alias">name of the alias</param>
            <param name="index">index for the alias</param>
            <returns>true if the alias was created </returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasCreateForIndexAsync(System.String,System.String)">
            <summary>
            Async Creates a new alias for the index parameter. 
            </summary>
            <param name="alias">name of the alias</param>
            <param name="index">index for the alias</param>
            <returns>true if the alias was created </returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Alias(System.String)">
            <summary>
            Creates any alias command depending on the json content
            </summary>
            <param name="jsonContent">content for the _aliases, see Elasticsearch documentation</param>
            <returns>returns true if the alias command was completed successfully</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Alias(ElasticsearchCRUD.ContextAlias.AliasModel.AliasParameters)">
             <summary>
             Creates any alias command depending on the json content
             var aliasParameters = new AliasParameters
            	{
            		Actions = new List AliasBaseParameters
            		{
            			new AliasAddParameters("test2", "indexaliasdtotests"),
            			new AliasAddParameters("test3", "indexaliasdtotests")
            		}
            	};
            
             </summary>
             <param name="aliasParameters">content for the _aliases, see Elasticsearch documentation</param>
             <returns>returns true if the alias command was completed successfully</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasAsync(System.String)">
            <summary>
            Async Creates any alias command depending on the json content
            </summary>
            <param name="jsonContent">content for the _aliases, see Elasticsearch documentation</param>
            <returns>returns true if the alias command was completed successfully</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasAsync(ElasticsearchCRUD.ContextAlias.AliasModel.AliasParameters)">
            <summary>
            Async Creates any alias command depending on the json content
            </summary>
            <param name="aliasParameters">content for the _aliases, see Elasticsearch documentation</param>
            <returns>returns true if the alias command was completed successfully</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasRemoveForIndex(System.String,System.String)">
            <summary>
            Removes a new alias for the index parameter. 
            </summary>
            <param name="alias">name of the alias</param>
            <param name="index">index for the alias</param>
            <returns>true if the alias was removed </returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasRemoveForIndexAsync(System.String,System.String)">
            <summary>
            asnyc Removes a new alias for the index parameter. 
            </summary>
            <param name="alias">name of the alias</param>
            <param name="index">index for the alias</param>
            <returns>true if the alias was removed </returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasReplaceIndex(System.String,System.String,System.String)">
            <summary>
            Replaces the index for the alias. This can be used when reindexing live
            </summary>
            <param name="alias">Name of the alias</param>
            <param name="indexOld">Old index which will be removed</param>
            <param name="indexNew">New index which will be mapped to the alias</param>
            <returns>Returns true if the index was replaced</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.AliasReplaceIndexAsync(System.String,System.String,System.String)">
            <summary>
            Async Replaces the index for the alias. This can be used when reindexing live
            </summary>
            <param name="alias">Name of the alias</param>
            <param name="indexOld">Old index which will be removed</param>
            <param name="indexNew">New index which will be mapped to the alias</param>
            <returns>Returns true if the index was replaced</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteIndexAsync``1">
            <summary>
            Delete the whole index if it exists and Elasticsearch allows delete index.
            Property AllowDeleteForIndex must also be set to true.
            </summary>
            <typeparam name="T">Type used to get the index to delete.</typeparam>
            <returns>Result details in a task</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteIndex``1">
            <summary>
            Delete the whole index if it exists and Elasticsearch allows delete index.
            Property AllowDeleteForIndex must also be set to true.
            </summary>
            <typeparam name="T">Type used to get the index to delete.</typeparam>
            <returns>Result details in a , true if ok</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteIndex(System.String)">
            <summary>
            Delete the whole index if it exists and Elasticsearch allows delete index.
            Property AllowDeleteForIndex must also be set to true.
            </summary>
            <returns>Result details in a , true if ok</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteIndexTypeAsync``1">
            <summary>
            Async Delete the whole index type if it exists and Elasticsearch allows delete index. This can be used for deleting child types in an existing index.
            Property AllowDeleteForIndex must also be set to true.
            </summary>
            <typeparam name="T">Type used to get the index to delete.</typeparam>
            <returns>Result details in a task</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.DeleteIndexType``1">
            <summary>
            Delete the whole index type if it exists and Elasticsearch allows delete index. This can be used for deleting child types in an existing index.
            Property AllowDeleteForIndex must also be set to true.
            </summary>
            <typeparam name="T">Type used to get the index to delete.</typeparam>
            <returns>Result details in a true if ok</returns>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchContext.Dispose">
            <summary>
            Dispose used to clean the HttpClient
            </summary>
        </member>
        <member name="P:ElasticsearchCRUD.ElasticsearchContext.AllowDeleteForIndex">
            <summary>
            This bool needs to be set to true if you want to delete an index. Per default this is false.
            </summary>
        </member>
        <member name="T:ElasticsearchCRUD.ElasticsearchMappingResolver">
            <summary>
            This class is used to add all register all the type definitions and then resolver them when requesting or handling response data from Elasticsearch.
            If no mapping is defined, the default mapping is used.
            </summary>
        </member>
        <member name="M:ElasticsearchCRUD.ElasticsearchMappingResolver.AddElasticSearchMappingForEntityType(System.Type,ElasticsearchCRUD.ElasticsearchMapping)">
            <summary>
            You can add custom Type handlers here for specific mapping.
            Only one mapping can be defined pro type.
            </summary>
            <param name="type">Type of class</param>
            <param name="mapping">mapping definition.</param>
        </member>
    </members>
</doc>
